-- Aggregated CREATE TABLE, CREATE TRIGGER, CREATE FUNCTION, and ALTER ADD COLUMN statements
-- Generated by build_full_schema.py

-- Source: 2025_add_effect_intensity_column.sql
ALTER TABLE IF EXISTS UserSetting
  ADD COLUMN IF NOT EXISTS effect_intensity VARCHAR(20) DEFAULT 'medium';

-- Source: 2025_add_essential_amino_acids.sql
CREATE OR REPLACE FUNCTION compute_user_amino_requirement(p_user_id INT, p_amino_id INT)
RETURNS TABLE(base NUMERIC, multiplier NUMERIC, recommended NUMERIC, unit TEXT) AS $$
DECLARE
    v_base NUMERIC;
    v_unit TEXT;
    v_gender TEXT;
    v_goal TEXT;
    v_activity NUMERIC;
    v_weight NUMERIC;
    v_age INT;
    v_mult NUMERIC := 1.0;
    v_per_kg BOOLEAN;
BEGIN
    -- pick the most specific AminoRequirement row matching sex/age if present
    SELECT ar.amount, ar.unit, ar.per_kg INTO v_base, v_unit, v_per_kg
    FROM AminoRequirement ar
    WHERE ar.amino_acid_id = p_amino_id
      AND (ar.sex IS NULL OR lower(ar.sex) = lower( (SELECT COALESCE(u.gender,'') FROM "User" u WHERE u.user_id = p_user_id) ) OR lower(ar.sex) = 'both')
      AND ( (ar.age_min IS NULL AND ar.age_max IS NULL) OR (
            (SELECT COALESCE(u.age,0) FROM "User" u WHERE u.user_id = p_user_id) BETWEEN COALESCE(ar.age_min, -9999) AND COALESCE(ar.age_max, 99999)
          ) )
    ORDER BY (ar.age_min IS NOT NULL) DESC, (ar.age_max IS NOT NULL) DESC
    LIMIT 1;

    IF v_base IS NULL THEN
        RETURN; -- no recommendation available
    END IF;

    SELECT u.gender, up.goal_type, COALESCE(up.activity_factor,1.2), u.weight_kg, u.age
    INTO v_gender, v_goal, v_activity, v_weight, v_age
    FROM "User" u LEFT JOIN UserProfile up ON up.user_id = u.user_id
    WHERE u.user_id = p_user_id;

    IF v_activity IS NULL THEN v_activity := 1.2; END IF;

    -- activity and goal heuristics (light): scale multiplier similar to vitamins/minerals
    IF v_activity > 1.2 THEN
        v_mult := v_mult + LEAST( (v_activity - 1.2) * 0.2, 0.20 );
    END IF;
    IF v_goal IS NOT NULL THEN
        IF lower(v_goal) = 'lose_weight' THEN v_mult := v_mult + 0.03; ELSIF lower(v_goal) = 'gain_weight' THEN v_mult := v_mult - 0.01; END IF;
    END IF;
    IF v_gender IS NOT NULL AND lower(v_gender) = 'male' THEN v_mult := v_mult + 0.02; END IF;

    -- compute final recommended number, handling per-kg
    IF v_per_kg = TRUE THEN
        IF v_weight IS NULL THEN
            RETURN; -- can't compute per-kg without weight
        END IF;PS D:\app> cd D:\app\my_diary
PS D:\app\my_diary> flutter analyze
Analyzing my_diary...                                                   

   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:858:34 -
          use_build_context_synchronously
   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:867:30 -
          use_build_context_synchronously
   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:870:30 -
          use_build_context_synchronously
   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:924:40 -
          use_build_context_synchronously
   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:927:40 -
          use_build_context_synchronously
   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:935:32 -
          use_build_context_synchronously
   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:941:40 -
          use_build_context_synchronously
   info - Don't use 'BuildContext's across async gaps, guarded by an unrelated 'mounted'
          check - lib\screens\personal_info_screen.dart:945:38 -
          use_build_context_synchronously

8 issues found. (ran in 4.8s)
PS D:\app\my_diary> 
        RETURN QUERY SELECT v_base, v_mult, ROUND(v_base * v_weight * v_mult, 3), v_unit;
    ELSE
        RETURN QUERY SELECT v_base, v_mult, ROUND(v_base * v_mult, 3), v_unit;
    END IF;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_userprofile_amino_refresh
AFTER INSERT OR UPDATE OF activity_factor, tdee, goal_type ON UserProfile
FOR EACH ROW EXECUTE FUNCTION trg_refresh_user_amino_from_userprofile();
CREATE TRIGGER trg_user_amino_refresh
AFTER UPDATE OF weight_kg, gender, age ON "User"
FOR EACH ROW WHEN (OLD.weight_kg IS DISTINCT FROM NEW.weight_kg OR OLD.gender IS DISTINCT FROM NEW.gender OR OLD.age IS DISTINCT FROM NEW.age)
EXECUTE FUNCTION trg_refresh_user_amino_from_user();
CREATE OR REPLACE FUNCTION refresh_user_amino_requirements(p_user_id INT) RETURNS VOID AS $$
DECLARE
    a RECORD;
    v_base NUMERIC;
    v_mult NUMERIC;
    v_rec NUMERIC;
    v_unit TEXT;
BEGIN
    IF p_user_id IS NULL THEN RETURN; END IF;
    FOR a IN SELECT amino_acid_id FROM AminoAcid LOOP
        SELECT base, multiplier, recommended, unit INTO v_base, v_mult, v_rec, v_unit FROM compute_user_amino_requirement(p_user_id, a.amino_acid_id);
        -- upsert if computed (v_rec may be NULL if cannot compute)
        IF v_rec IS NOT NULL THEN
            INSERT INTO UserAminoRequirement(user_id, amino_acid_id, base, multiplier, recommended, unit, updated_at)
            VALUES (p_user_id, a.amino_acid_id, v_base, v_mult, v_rec, v_unit, NOW())
            ON CONFLICT (user_id, amino_acid_id) DO UPDATE
            SET base = EXCLUDED.base, multiplier = EXCLUDED.multiplier, recommended = EXCLUDED.recommended, unit = EXCLUDED.unit, updated_at = EXCLUDED.updated_at;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_amino_from_userprofile() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_amino_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_amino_from_user() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_amino_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_add_fiber_fatty_acids.sql
CREATE OR REPLACE FUNCTION compute_user_fiber_requirement(p_user_id INT, p_fiber_id INT)
RETURNS TABLE(base NUMERIC, multiplier NUMERIC, recommended NUMERIC, unit TEXT) AS $$
DECLARE
    v_base NUMERIC;
    v_unit TEXT;
    v_gender TEXT;
    v_goal TEXT;
    v_activity NUMERIC;
    v_weight NUMERIC;
    v_tdee NUMERIC;
    v_age INT;
    v_mult NUMERIC := 1.0;
    v_req RECORD;
    v_rec NUMERIC;
BEGIN
    SELECT * INTO v_req FROM FiberRequirement r
    WHERE r.fiber_id = p_fiber_id
      AND (r.sex IS NULL OR lower(r.sex) = lower((SELECT COALESCE(u.gender,'') FROM "User" u WHERE u.user_id = p_user_id)))
      AND ( (r.age_min IS NULL AND r.age_max IS NULL) OR (
            (SELECT COALESCE(u.age,0) FROM "User" u WHERE u.user_id = p_user_id) BETWEEN COALESCE(r.age_min, -9999) AND COALESCE(r.age_max, 99999)
          ) )
    LIMIT 1;

    IF v_req IS NULL THEN
        -- nothing found
        RETURN;
    END IF;

    v_base := v_req.base_value;
    v_unit := COALESCE(v_req.unit, 'g');

    SELECT u.gender, up.goal_type, COALESCE(up.activity_factor,1.2), u.weight_kg, COALESCE(up.tdee,0), u.age
    INTO v_gender, v_goal, v_activity, v_weight, v_tdee, v_age
    FROM "User" u LEFT JOIN UserProfile up ON up.user_id = u.user_id
    WHERE u.user_id = p_user_id;

    IF v_activity IS NULL THEN v_activity := 1.2; END IF;

    -- small activity/goal/gender multipliers to adjust fiber needs
    IF v_activity > 1.2 THEN
        v_mult := v_mult + LEAST( (v_activity - 1.2) * 0.10, 0.10 );
    END IF;
    IF v_goal IS NOT NULL THEN
        IF lower(v_goal) = 'lose_weight' THEN v_mult := v_mult + 0.05;
        ELSIF lower(v_goal) = 'gain_weight' THEN v_mult := v_mult - 0.02; END IF;
    END IF;
    IF v_gender IS NOT NULL AND lower(v_gender) = 'male' THEN v_mult := v_mult + 0.02; END IF;

    -- per-kg: multiply base_value by weight if required
    IF v_req.is_per_kg THEN
        IF v_weight IS NOT NULL THEN
            v_rec := ROUND(COALESCE(v_base,0) * v_weight * v_mult, 3);
        ELSE
            v_rec := NULL;
        END IF;
    ELSE
        v_rec := ROUND(COALESCE(v_base,0) * v_mult, 3);
    END IF;

    RETURN QUERY SELECT v_base, v_mult, v_rec, v_unit;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_userprofile_fiber_refresh
AFTER INSERT OR UPDATE OF activity_factor, tdee, goal_type ON UserProfile
FOR EACH ROW EXECUTE FUNCTION trg_refresh_user_fiber_from_userprofile();
CREATE TRIGGER trg_userprofile_fatty_refresh
AFTER INSERT OR UPDATE OF activity_factor, tdee, goal_type ON UserProfile
FOR EACH ROW EXECUTE FUNCTION trg_refresh_user_fatty_from_userprofile();
CREATE TRIGGER trg_user_fiber_refresh
AFTER UPDATE OF weight_kg, gender ON "User"
FOR EACH ROW WHEN (OLD.weight_kg IS DISTINCT FROM NEW.weight_kg OR OLD.gender IS DISTINCT FROM NEW.gender)
EXECUTE FUNCTION trg_refresh_user_fiber_from_user();
CREATE TRIGGER trg_user_fatty_refresh
AFTER UPDATE OF weight_kg, gender ON "User"
FOR EACH ROW WHEN (OLD.weight_kg IS DISTINCT FROM NEW.weight_kg OR OLD.gender IS DISTINCT FROM NEW.gender)
EXECUTE FUNCTION trg_refresh_user_fatty_from_user();
CREATE TRIGGER trg_compute_fiber_fattyintake
AFTER INSERT OR UPDATE OR DELETE ON MealItem
FOR EACH ROW EXECUTE FUNCTION compute_and_upsert_fiber_fattyintake();
CREATE OR REPLACE FUNCTION compute_user_fattyacid_requirement(p_user_id INT, p_fa_id INT)
RETURNS TABLE(base NUMERIC, multiplier NUMERIC, recommended NUMERIC, unit TEXT) AS $$
DECLARE
    v_req RECORD;
    v_base NUMERIC;
    v_unit TEXT;
    v_gender TEXT;
    v_goal TEXT;
    v_activity NUMERIC;
    v_weight NUMERIC;
    v_tdee NUMERIC;
    v_age INT;
    v_mult NUMERIC := 1.0;
    v_rec NUMERIC;
    v_energy_kcal NUMERIC;
    v_code TEXT;
    v_base_pct NUMERIC;
BEGIN
    SELECT * INTO v_req FROM FattyAcidRequirement r
    WHERE r.fatty_acid_id = p_fa_id
      AND (r.sex IS NULL OR lower(r.sex) = lower((SELECT COALESCE(u.gender,'') FROM "User" u WHERE u.user_id = p_user_id)))
      AND ( (r.age_min IS NULL AND r.age_max IS NULL) OR (
            (SELECT COALESCE(u.age,0) FROM "User" u WHERE u.user_id = p_user_id) BETWEEN COALESCE(r.age_min, -9999) AND COALESCE(r.age_max, 99999)
          ) )
    LIMIT 1;

    IF v_req IS NULL THEN RETURN; END IF;

    v_base := v_req.base_value;
    v_unit := COALESCE(v_req.unit, 'g');

    SELECT u.gender, up.goal_type, COALESCE(up.activity_factor,1.2), u.weight_kg, COALESCE(up.tdee,0), COALESCE(up.daily_calorie_target,0), u.age
    INTO v_gender, v_goal, v_activity, v_weight, v_tdee, v_energy_kcal, v_age
    FROM "User" u LEFT JOIN UserProfile up ON up.user_id = u.user_id
    WHERE u.user_id = p_user_id;

    IF v_activity IS NULL THEN v_activity := 1.2; END IF;

    IF v_activity > 1.2 THEN
        v_mult := v_mult + LEAST( (v_activity - 1.2) * 0.10, 0.10 );
    END IF;
    IF v_goal IS NOT NULL THEN
        IF lower(v_goal) = 'lose_weight' THEN v_mult := v_mult + 0.03;
        ELSIF lower(v_goal) = 'gain_weight' THEN v_mult := v_mult - 0.02; END IF;
    END IF;
    IF v_gender IS NOT NULL AND lower(v_gender) = 'male' THEN v_mult := v_mult + 0.02; END IF;

    -- Determine a sensible energy baseline (TDEE > daily_calorie_target > fallback 2000)
    IF v_tdee IS NULL OR v_tdee = 0 THEN
        v_tdee := v_energy_kcal;
    END IF;
    IF v_tdee IS NULL OR v_tdee = 0 THEN
        v_tdee := 2000; -- fallback kcal/day
    END IF;

    -- fetch canonical code for special-case nutrients (EPA/DHA/CHOLESTEROL)
    SELECT code INTO v_code FROM FattyAcid WHERE fatty_acid_id = p_fa_id LIMIT 1;

    IF v_req.is_energy_pct THEN
        -- convert energy percent (0-100) into grams of fat: grams = (pct/100 * kcal) / 9
        -- start with configured pct or base_value if stored as pct
        v_base_pct := COALESCE(v_req.energy_pct, v_req.base_value, 0);

        -- Apply demographic/activity adjustments for total fat group as requested:
        -- Male: +10% total fat
        -- Age 51-70: -5% total energy from fat
        -- Activity >= 1.725: +5% total energy from fat
        IF v_gender IS NOT NULL AND lower(v_gender) LIKE 'm%' THEN
            v_base_pct := v_base_pct * 1.10; -- +10%
        END IF;
        IF v_age IS NOT NULL AND v_age BETWEEN 51 AND 70 THEN
            v_base_pct := v_base_pct * 0.95; -- -5%
        END IF;
        IF v_activity IS NOT NULL AND v_activity >= 1.725 THEN
            v_base_pct := v_base_pct * 1.05; -- +5%
        END IF;

        -- final recommended grams from energy percent
        v_rec := ROUND( (COALESCE(v_base_pct,0) / 100.0) * v_tdee / 9.0 * v_mult, 3);
        v_base := v_base_pct; -- report base as pct
        v_unit := 'g';
    ELSE
        -- handle special mg-based nutrients (EPA/DHA combined and Cholesterol)
        IF v_code IS NOT NULL AND (upper(v_code) = 'EPA' OR upper(v_code) = 'DHA' OR upper(v_code) = 'EPA_DHA' OR upper(v_code) = 'EPA+DHA') THEN
            -- EPA+DHA baseline: 250 mg; males +100 mg
            v_rec := ROUND( (COALESCE(v_req.base_value,250) + CASE WHEN lower(v_gender) LIKE 'm%' THEN 100 ELSE 0 END) * v_mult , 0);
            v_base := COALESCE(v_req.base_value,250);
            v_unit := 'mg';
        ELSIF v_code IS NOT NULL AND upper(v_code) = 'CHOLESTEROL' THEN
            -- Cholesterol mg: default 300 mg, reduce to 200 mg for age 51-70
            v_rec := COALESCE(v_req.base_value,300);
            IF v_age IS NOT NULL AND v_age BETWEEN 51 AND 70 THEN
                v_rec := v_rec - 100;
            END IF;
            v_rec := ROUND(v_rec * v_mult, 0);
            v_base := COALESCE(v_req.base_value,300);
            v_unit := 'mg';
        ELSE
            -- standard gram-based or per-kg rules
            IF v_req.is_per_kg THEN
                IF v_weight IS NOT NULL THEN
                    v_rec := ROUND( COALESCE(v_base,0) * v_weight * v_mult, 3);
                ELSE
                    v_rec := NULL;
                END IF;
            ELSE
                v_rec := ROUND( COALESCE(v_base,0) * v_mult, 3);
            END IF;
        END IF;
    END IF;

    RETURN QUERY SELECT v_base, v_mult, v_rec, v_unit;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION refresh_user_fiber_requirements(p_user_id INT) RETURNS VOID AS $$
DECLARE
    v RECORD;
    v_base NUMERIC;
    v_mult NUMERIC;
    v_rec NUMERIC;
    v_unit TEXT;
BEGIN
    IF p_user_id IS NULL THEN RETURN; END IF;
    FOR v IN SELECT fiber_id FROM Fiber LOOP
        SELECT base, multiplier, recommended, unit INTO v_base, v_mult, v_rec, v_unit FROM compute_user_fiber_requirement(p_user_id, v.fiber_id);
        INSERT INTO UserFiberRequirement(user_id, fiber_id, base, multiplier, recommended, unit, updated_at)
        VALUES (p_user_id, v.fiber_id, v_base, v_mult, v_rec, v_unit, NOW())
        ON CONFLICT (user_id, fiber_id) DO UPDATE
        SET base = EXCLUDED.base, multiplier = EXCLUDED.multiplier, recommended = EXCLUDED.recommended, unit = EXCLUDED.unit, updated_at = EXCLUDED.updated_at;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION refresh_user_fatty_requirements(p_user_id INT) RETURNS VOID AS $$
DECLARE
    v RECORD;
    v_base NUMERIC;
    v_mult NUMERIC;
    v_rec NUMERIC;
    v_unit TEXT;
BEGIN
    IF p_user_id IS NULL THEN RETURN; END IF;
    FOR v IN SELECT fatty_acid_id FROM FattyAcid LOOP
        SELECT base, multiplier, recommended, unit INTO v_base, v_mult, v_rec, v_unit FROM compute_user_fattyacid_requirement(p_user_id, v.fatty_acid_id);
        INSERT INTO UserFattyAcidRequirement(user_id, fatty_acid_id, base, multiplier, recommended, unit, updated_at)
        VALUES (p_user_id, v.fatty_acid_id, v_base, v_mult, v_rec, v_unit, NOW())
        ON CONFLICT (user_id, fatty_acid_id) DO UPDATE
        SET base = EXCLUDED.base, multiplier = EXCLUDED.multiplier, recommended = EXCLUDED.recommended, unit = EXCLUDED.unit, updated_at = EXCLUDED.updated_at;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_fiber_from_userprofile() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_fiber_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_fatty_from_userprofile() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_fatty_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_fiber_from_user() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_fiber_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_fatty_from_user() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_fatty_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION compute_and_upsert_fiber_fattyintake() RETURNS trigger AS $$
DECLARE
    v_user INT;
    v_date DATE;
    v_fiber_amount NUMERIC := 0;
    v_fatty_amount NUMERIC := 0;
    rec RECORD;
    v_weight_factor NUMERIC;
BEGIN
    -- find user and date for the meal
    IF TG_OP = 'DELETE' THEN
        SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = OLD.meal_id;
    ELSE
        SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = NEW.meal_id;
    END IF;

    -- determine grams for the meal item (weight_g)
    IF TG_OP = 'DELETE' THEN
        v_weight_factor := OLD.weight_g / 100.0;
    ELSE
        v_weight_factor := NEW.weight_g / 100.0;
    END IF;

    -- iterate fiber nutrients (heuristic codes: 'FIBTG' common in USDA)
    v_fiber_amount := 0;
    FOR rec IN
        SELECT fn.amount_per_100g
        FROM FoodNutrient fn JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = COALESCE(NEW.food_id, OLD.food_id)
          AND (upper(n.nutrient_code) = 'FIBTG' OR lower(n.name) LIKE '%fiber%' OR lower(n.name) LIKE '%fibre%')
    LOOP
        v_fiber_amount := v_fiber_amount + COALESCE(rec.amount_per_100g,0) * v_weight_factor;
    END LOOP;

    -- iterate fatty acid nutrient heuristics (common codes: 'FAMS'(MUFA), 'FAPU'(PUFA), 'FATRN'(trans), 'FAEPA','FADHA')
    v_fatty_amount := 0;
    FOR rec IN
        SELECT fn.amount_per_100g, n.nutrient_id, n.name, n.nutrient_code
        FROM FoodNutrient fn JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = COALESCE(NEW.food_id, OLD.food_id)
          AND (
              upper(n.nutrient_code) IN ('FAMS','FAPU','FATRN','FA18_2N6C','FA18_3N3','FAEPA','FADHA')
              OR lower(n.name) LIKE '%saturated fat%' OR lower(n.name) LIKE '%monounsaturated%' OR lower(n.name) LIKE '%polyunsat%'
              OR lower(n.name) LIKE '%epa%' OR lower(n.name) LIKE '%dha%' OR lower(n.name) LIKE '%cholesterol%'
          )
    LOOP
        v_fatty_amount := v_fatty_amount + COALESCE(rec.amount_per_100g,0) * v_weight_factor;
    END LOOP;

    -- Upsert fiber intake: we will distribute total fiber into the canonical Fiber rows by matching the primary Fiber entry 'TOTAL_FIBER' if exists
    PERFORM upsert_user_fiber_intake(v_user, v_date, v_fiber_amount);

    -- Upsert fatty intake into a generic fatty acid entry 'TOTAL_FAT' if exists
    PERFORM upsert_user_fatty_intake(v_user, v_date, v_fatty_amount);

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION upsert_user_fiber_intake(p_user INT, p_date DATE, p_amount NUMERIC) RETURNS VOID AS $$
DECLARE
    v_fiber_id INT;
BEGIN
    -- prefer a Fiber with code 'TOTAL_FIBER' else do nothing
    SELECT fiber_id INTO v_fiber_id FROM Fiber WHERE code = 'TOTAL_FIBER' LIMIT 1;
    IF v_fiber_id IS NULL THEN RETURN; END IF;

    INSERT INTO UserFiberIntake(user_id, date, fiber_id, amount)
    VALUES (p_user, p_date, v_fiber_id, COALESCE(p_amount,0))
    ON CONFLICT (user_id, date, fiber_id) DO UPDATE
    SET amount = COALESCE(UserFiberIntake.amount,0) + EXCLUDED.amount;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION upsert_user_fatty_intake(p_user INT, p_date DATE, p_amount NUMERIC) RETURNS VOID AS $$
DECLARE
    v_fa_id INT;
BEGIN
    -- prefer a FattyAcid with code 'TOTAL_FAT' else do nothing
    SELECT fatty_acid_id INTO v_fa_id FROM FattyAcid WHERE code = 'TOTAL_FAT' LIMIT 1;
    IF v_fa_id IS NULL THEN RETURN; END IF;

    INSERT INTO UserFattyAcidIntake(user_id, date, fatty_acid_id, amount)
    VALUES (p_user, p_date, v_fa_id, COALESCE(p_amount,0))
    ON CONFLICT (user_id, date, fatty_acid_id) DO UPDATE
    SET amount = COALESCE(UserFattyAcidIntake.amount,0) + EXCLUDED.amount;
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_add_macro_columns.sql
ALTER TABLE IF EXISTS UserSetting
  ADD COLUMN IF NOT EXISTS calorie_multiplier DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS macro_protein_pct DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS macro_fat_pct DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS macro_carb_pct DOUBLE PRECISION;

-- Source: 2025_add_meal_distribution_columns.sql
ALTER TABLE IF EXISTS UserSetting
    ADD COLUMN IF NOT EXISTS meal_pct_breakfast NUMERIC(5,2) DEFAULT 25.00,
    ADD COLUMN IF NOT EXISTS meal_pct_lunch NUMERIC(5,2) DEFAULT 35.00,
    ADD COLUMN IF NOT EXISTS meal_pct_snack NUMERIC(5,2) DEFAULT 10.00,
    ADD COLUMN IF NOT EXISTS meal_pct_dinner NUMERIC(5,2) DEFAULT 30.00;

-- Source: 2025_add_nutrient_admin_fields.sql
ALTER TABLE IF EXISTS Nutrient
    ADD COLUMN IF NOT EXISTS group_name VARCHAR(50),
    ADD COLUMN IF NOT EXISTS image_url TEXT,
    ADD COLUMN IF NOT EXISTS benefits TEXT;
CREATE TABLE IF NOT EXISTS NutrientContraindication (
    contra_id SERIAL PRIMARY KEY,
    nutrient_id INT REFERENCES Nutrient(nutrient_id) ON DELETE CASCADE,
    condition_name VARCHAR(100) NOT NULL,
    note TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(nutrient_id, condition_name)
);

-- Source: 2025_add_nutrient_mapping_for_fiber_and_fatty.sql
CREATE OR REPLACE FUNCTION upsert_user_fiber_intake_specific(p_user INT, p_date DATE, p_fiber_id INT, p_amount NUMERIC) RETURNS VOID AS $$
BEGIN
    IF p_fiber_id IS NULL THEN RETURN; END IF;
    INSERT INTO UserFiberIntake(user_id, date, fiber_id, amount)
    VALUES (p_user, p_date, p_fiber_id, COALESCE(p_amount,0))
    ON CONFLICT (user_id, date, fiber_id) DO UPDATE
    SET amount = COALESCE(UserFiberIntake.amount,0) + EXCLUDED.amount;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION upsert_user_fatty_intake_specific(p_user INT, p_date DATE, p_fatty_id INT, p_amount NUMERIC) RETURNS VOID AS $$
BEGIN
    IF p_fatty_id IS NULL THEN RETURN; END IF;
    INSERT INTO UserFattyAcidIntake(user_id, date, fatty_acid_id, amount)
    VALUES (p_user, p_date, p_fatty_id, COALESCE(p_amount,0))
    ON CONFLICT (user_id, date, fatty_acid_id) DO UPDATE
    SET amount = COALESCE(UserFattyAcidIntake.amount,0) + EXCLUDED.amount;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION compute_and_upsert_fiber_fattyintake() RETURNS trigger AS $$
DECLARE
    v_user INT;
    v_date DATE;
    rec RECORD;
    v_weight_factor NUMERIC;
    v_food_id INT;
BEGIN
    IF TG_OP = 'DELETE' THEN
        SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = OLD.meal_id;
        v_food_id := OLD.food_id;
        v_weight_factor := OLD.weight_g / 100.0;
    ELSE
        SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = NEW.meal_id;
        v_food_id := NEW.food_id;
        v_weight_factor := NEW.weight_g / 100.0;
    END IF;

    IF v_food_id IS NULL OR v_user IS NULL OR v_date IS NULL THEN
        RETURN NULL;
    END IF;

    FOR rec IN
        SELECT nm.fiber_id, nm.fatty_acid_id, nm.factor, fn.amount_per_100g
        FROM FoodNutrient fn
        JOIN NutrientMapping nm ON nm.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = v_food_id
    LOOP
        IF rec.fiber_id IS NOT NULL THEN
            PERFORM upsert_user_fiber_intake_specific(v_user, v_date, rec.fiber_id, COALESCE(rec.amount_per_100g,0) * COALESCE(rec.factor,1.0) * v_weight_factor);
        END IF;
        IF rec.fatty_acid_id IS NOT NULL THEN
            PERFORM upsert_user_fatty_intake_specific(v_user, v_date, rec.fatty_acid_id, COALESCE(rec.amount_per_100g,0) * COALESCE(rec.factor,1.0) * v_weight_factor);
        END IF;
    END LOOP;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_add_nutrient_tracking_notifications.sql
CREATE TABLE IF NOT EXISTS UserNutrientTracking (
    tracking_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    nutrient_type VARCHAR(20) NOT NULL, -- 'vitamin', 'mineral', 'fiber', 'fatty_acid'
    nutrient_id INT NOT NULL, -- ID from respective table
    target_amount NUMERIC(10,3),
    current_amount NUMERIC(10,3) DEFAULT 0,
    unit VARCHAR(20),
    last_updated TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, date, nutrient_type, nutrient_id)
);
CREATE TABLE IF NOT EXISTS UserNutrientNotification (
    notification_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    nutrient_type VARCHAR(20) NOT NULL,
    nutrient_id INT NOT NULL,
    nutrient_name VARCHAR(100),
    notification_type VARCHAR(50) NOT NULL, -- 'deficiency_warning', 'daily_reminder', 'goal_achieved'
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    severity VARCHAR(20) DEFAULT 'info', -- 'info', 'warning', 'critical'
    is_read BOOLEAN DEFAULT FALSE,
    metadata JSONB, -- Store additional data like percentage, amounts, etc.
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE OR REPLACE FUNCTION calculate_daily_nutrient_intake(
    p_user_id INT,
    p_date DATE
) RETURNS TABLE(
    nutrient_type VARCHAR(20),
    nutrient_id INT,
    nutrient_code VARCHAR(50),
    nutrient_name VARCHAR(100),
    current_amount NUMERIC,
    target_amount NUMERIC,
    unit VARCHAR(20),
    percentage NUMERIC
) AS $$
BEGIN
    -- Calculate vitamin intake from meals
    RETURN QUERY
    WITH meal_items_today AS (
        SELECT mi.food_id, mi.weight_g
        FROM MealItem mi
        JOIN Meal m ON m.meal_id = mi.meal_id
        WHERE m.user_id = p_user_id AND m.meal_date = p_date
    ),
    vitamin_intake AS (
        SELECT 
            'vitamin'::VARCHAR(20) as nutrient_type,
            v.vitamin_id::INT as nutrient_id,
            v.code as nutrient_code,
            v.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(uvr.recommended, v.recommended_daily::NUMERIC, 0) as target_amount,
            v.unit,
            CASE 
                WHEN COALESCE(uvr.recommended, v.recommended_daily::NUMERIC, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(uvr.recommended, v.recommended_daily::NUMERIC, 1)) * 100
                ELSE 0 
            END as percentage
        FROM Vitamin v
        LEFT JOIN UserVitaminRequirement uvr ON uvr.vitamin_id = v.vitamin_id AND uvr.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(v.code)
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY v.vitamin_id, v.code, v.name, v.unit, v.recommended_daily, uvr.recommended
    ),
    mineral_intake AS (
        SELECT 
            'mineral'::VARCHAR(20) as nutrient_type,
            m.mineral_id::INT as nutrient_id,
            m.code as nutrient_code,
            m.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(umr.recommended, m.recommended_daily::NUMERIC, 0) as target_amount,
            m.unit,
            CASE 
                WHEN COALESCE(umr.recommended, m.recommended_daily::NUMERIC, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(umr.recommended, m.recommended_daily::NUMERIC, 1)) * 100
                ELSE 0 
            END as percentage
        FROM Mineral m
        LEFT JOIN UserMineralRequirement umr ON umr.mineral_id = m.mineral_id AND umr.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(REPLACE(m.code, 'MIN_', ''))
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY m.mineral_id, m.code, m.name, m.unit, m.recommended_daily, umr.recommended
    ),
    amino_acid_intake AS (
        SELECT 
            'amino_acid'::VARCHAR(20) as nutrient_type,
            aa.amino_acid_id::INT as nutrient_id,
            aa.code as nutrient_code,
            aa.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(uar.recommended, 0) as target_amount,
            'mg'::VARCHAR(20) as unit,
            CASE 
                WHEN COALESCE(uar.recommended, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(uar.recommended, 1)) * 100
                ELSE 0 
            END as percentage
        FROM AminoAcid aa
        LEFT JOIN UserAminoRequirement uar ON uar.amino_acid_id = aa.amino_acid_id AND uar.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER('AMINO_' || aa.code)
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY aa.amino_acid_id, aa.code, aa.name, uar.recommended
    ),
    fiber_intake AS (
        SELECT 
            'fiber'::VARCHAR(20) as nutrient_type,
            f.fiber_id::INT as nutrient_id,
            f.code as nutrient_code,
            f.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(ufr.recommended, 0) as target_amount,
            f.unit,
            CASE 
                WHEN COALESCE(ufr.recommended, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(ufr.recommended, 1)) * 100
                ELSE 0 
            END as percentage
        FROM Fiber f
        LEFT JOIN UserFiberRequirement ufr ON ufr.fiber_id = f.fiber_id AND ufr.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(
            CASE f.code
                WHEN 'TOTAL_FIBER' THEN 'FIBTG'
                WHEN 'SOLUBLE_FIBER' THEN 'FIB_SOL'
                WHEN 'INSOLUBLE_FIBER' THEN 'FIB_INSOL'
                WHEN 'RESISTANT_STARCH' THEN 'FIB_RS'
                WHEN 'BETA_GLUCAN' THEN 'FIB_BGLU'
                ELSE f.code
            END
        )
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY f.fiber_id, f.code, f.name, f.unit, ufr.recommended
    ),
    fatty_acid_intake AS (
        SELECT 
            'fatty_acid'::VARCHAR(20) as nutrient_type,
            fa.fatty_acid_id::INT as nutrient_id,
            fa.code as nutrient_code,
            fa.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(ufar.recommended, 0) as target_amount,
            fa.unit,
            CASE 
                WHEN COALESCE(ufar.recommended, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(ufar.recommended, 1)) * 100
                ELSE 0 
            END as percentage
        FROM FattyAcid fa
        LEFT JOIN UserFattyAcidRequirement ufar ON ufar.fatty_acid_id = fa.fatty_acid_id AND ufar.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(
            CASE fa.code
                WHEN 'TOTAL_FAT' THEN 'FAT'
                WHEN 'SFA' THEN 'FASAT'
                WHEN 'MUFA' THEN 'FAMS'
                WHEN 'PUFA' THEN 'FAPU'
                WHEN 'ALA' THEN 'FA18_3N3'
                WHEN 'EPA' THEN 'FAEPA'
                WHEN 'DHA' THEN 'FADHA'
                WHEN 'EPA_DHA' THEN 'FAEPA_DHA'
                WHEN 'LA' THEN 'FA18_2N6C'
                WHEN 'TRANS_FAT' THEN 'FATRN'
                ELSE fa.code
            END
        )
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY fa.fatty_acid_id, fa.code, fa.name, fa.unit, ufar.recommended
    )
    SELECT * FROM vitamin_intake
    UNION ALL
    SELECT * FROM mineral_intake
    UNION ALL
    SELECT * FROM amino_acid_intake
    UNION ALL
    SELECT * FROM fiber_intake
    UNION ALL
    SELECT * FROM fatty_acid_intake;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_update_nutrient_tracking
AFTER INSERT OR UPDATE OR DELETE ON MealItem
FOR EACH ROW EXECUTE FUNCTION update_nutrient_tracking();
CREATE OR REPLACE FUNCTION check_and_notify_nutrient_deficiencies(
    p_user_id INT,
    p_date DATE DEFAULT CURRENT_DATE
) RETURNS INT AS $$
DECLARE
    v_nutrient RECORD;
    v_notification_count INT := 0;
    v_title TEXT;
    v_message TEXT;
    v_severity VARCHAR(20);
BEGIN
    -- Check nutrients at end of day (e.g., 8pm or later)
    FOR v_nutrient IN 
        SELECT * FROM calculate_daily_nutrient_intake(p_user_id, p_date)
        WHERE percentage < 50 -- Less than 50% of target
    LOOP
        -- Determine severity based on percentage
        IF v_nutrient.percentage < 25 THEN
            v_severity := 'critical';
            v_title := '⚠️ Thiếu hụt nghiêm trọng: ' || v_nutrient.nutrient_name;
            v_message := 'Bạn chỉ đạt ' || ROUND(v_nutrient.percentage, 0) || '% nhu cầu ' || v_nutrient.nutrient_name || 
                        ' (' || ROUND(v_nutrient.current_amount, 1) || '/' || ROUND(v_nutrient.target_amount, 1) || ' ' || v_nutrient.unit || 
                        '). Hãy bổ sung ngay!';
        ELSIF v_nutrient.percentage < 50 THEN
            v_severity := 'warning';
            v_title := '⚡ Cần bổ sung: ' || v_nutrient.nutrient_name;
            v_message := 'Bạn đã đạt ' || ROUND(v_nutrient.percentage, 0) || '% nhu cầu ' || v_nutrient.nutrient_name || 
                        ' (' || ROUND(v_nutrient.current_amount, 1) || '/' || ROUND(v_nutrient.target_amount, 1) || ' ' || v_nutrient.unit || 
                        '). Còn ' || ROUND(v_nutrient.target_amount - v_nutrient.current_amount, 1) || ' ' || v_nutrient.unit || ' nữa.';
        ELSE
            CONTINUE; -- Skip if not deficient
        END IF;

        -- Insert notification if not already exists today
        INSERT INTO UserNutrientNotification(
            user_id, nutrient_type, nutrient_id, nutrient_name,
            notification_type, title, message, severity, is_read,
            metadata
        )
        SELECT 
            p_user_id, 
            v_nutrient.nutrient_type, 
            v_nutrient.nutrient_id, 
            v_nutrient.nutrient_name,
            'deficiency_warning',
            v_title,
            v_message,
            v_severity,
            FALSE,
            jsonb_build_object(
                'date', p_date,
                'current_amount', v_nutrient.current_amount,
                'target_amount', v_nutrient.target_amount,
                'unit', v_nutrient.unit,
                'percentage', v_nutrient.percentage,
                'nutrient_code', v_nutrient.nutrient_code
            )
        WHERE NOT EXISTS (
            SELECT 1 FROM UserNutrientNotification
            WHERE user_id = p_user_id 
            AND nutrient_type = v_nutrient.nutrient_type
            AND nutrient_id = v_nutrient.nutrient_id
            AND notification_type = 'deficiency_warning'
            AND DATE(created_at) = p_date
        );

        IF FOUND THEN
            v_notification_count := v_notification_count + 1;
        END IF;
    END LOOP;

    RETURN v_notification_count;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION update_nutrient_tracking() RETURNS TRIGGER AS $$
DECLARE
    v_user_id INT;
    v_meal_date DATE;
BEGIN
    -- Get user_id and meal_date from the meal
    SELECT m.user_id, m.meal_date INTO v_user_id, v_meal_date
    FROM Meal m WHERE m.meal_id = COALESCE(NEW.meal_id, OLD.meal_id);

    -- Refresh tracking for this user and date
    -- This will be done via backend API call after meal operations
    -- But we can insert a placeholder here
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_add_usersetting_columns.sql
ALTER TABLE IF EXISTS UserSetting
  ADD COLUMN IF NOT EXISTS seasonal_ui_enabled BOOLEAN DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS seasonal_mode VARCHAR(20) DEFAULT 'auto',
  ADD COLUMN IF NOT EXISTS seasonal_custom_bg TEXT,
  ADD COLUMN IF NOT EXISTS falling_leaves_enabled BOOLEAN DEFAULT TRUE,
  ADD COLUMN IF NOT EXISTS weather_enabled BOOLEAN DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS weather_city VARCHAR(100),
  ADD COLUMN IF NOT EXISTS weather_last_update TIMESTAMP,
  ADD COLUMN IF NOT EXISTS weather_last_data JSONB,
  ADD COLUMN IF NOT EXISTS background_image_url TEXT;
ALTER TABLE IF EXISTS UserSetting
  ADD COLUMN IF NOT EXISTS theme VARCHAR(20) DEFAULT 'light',
  ADD COLUMN IF NOT EXISTS language VARCHAR(10) DEFAULT 'vi',
  ADD COLUMN IF NOT EXISTS font_size VARCHAR(20) DEFAULT 'medium',
  ADD COLUMN IF NOT EXISTS unit_system VARCHAR(10) DEFAULT 'metric';

-- Source: 2025_add_weather_effects_column.sql
ALTER TABLE IF EXISTS UserSetting
  ADD COLUMN IF NOT EXISTS weather_effects_enabled BOOLEAN DEFAULT TRUE;

-- Source: 2025_add_wind_direction_column.sql
ALTER TABLE "UserSetting"
  ADD COLUMN IF NOT EXISTS wind_direction DOUBLE PRECISION DEFAULT 0;

-- Source: 2025_body_measurement_tracking.sql
CREATE TABLE IF NOT EXISTS BodyMeasurement (
    measurement_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    measurement_date TIMESTAMP DEFAULT NOW(),
    weight_kg NUMERIC(5,2) CHECK (weight_kg > 0),
    height_cm NUMERIC(5,2) CHECK (height_cm > 0),
    bmi NUMERIC(4,2),
    bmi_score INT CHECK (bmi_score >= 1 AND bmi_score <= 10), -- Health score 1-10
    bmi_category VARCHAR(20), -- underweight, normal, overweight, obese
    source VARCHAR(50) DEFAULT 'manual', -- manual, smart_scale, app_calculated
    notes TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);
Create function to calculate BMI automatically
CREATE OR REPLACE FUNCTION calculate_bmi_and_score()
RETURNS TRIGGER AS $$
DECLARE
    calculated_bmi NUMERIC(4,2);
    score INT;
    category VARCHAR(20);
BEGIN
    -- Calculate BMI
    IF NEW.weight_kg IS NOT NULL AND NEW.height_cm IS NOT NULL AND NEW.height_cm > 0 THEN
        calculated_bmi := NEW.weight_kg / ((NEW.height_cm / 100.0) * (NEW.height_cm / 100.0));
        NEW.bmi := calculated_bmi;
        
        -- Calculate BMI score (1-10) and category
        -- WHO BMI categories with scoring
        IF calculated_bmi < 16.0 THEN
            score := 2; category := 'severely_underweight';
        ELSIF calculated_bmi < 17.0 THEN
            score := 3; category := 'underweight';
        ELSIF calculated_bmi < 18.5 THEN
            score := 5; category := 'mild_underweight';
        ELSIF calculated_bmi >= 18.5 AND calculated_bmi < 21.0 THEN
            score := 9; category := 'normal';
        ELSIF calculated_bmi >= 21.0 AND calculated_bmi < 25.0 THEN
            score := 10; category := 'optimal'; -- Peak score
        ELSIF calculated_bmi >= 25.0 AND calculated_bmi < 27.0 THEN
            score := 8; category := 'normal_high';
        ELSIF calculated_bmi >= 27.0 AND calculated_bmi < 30.0 THEN
            score := 6; category := 'overweight';
        ELSIF calculated_bmi >= 30.0 AND calculated_bmi < 35.0 THEN
            score := 4; category := 'obese_class_1';
        ELSIF calculated_bmi >= 35.0 AND calculated_bmi < 40.0 THEN
            score := 2; category := 'obese_class_2';
        ELSE
            score := 1; category := 'obese_class_3';
        END IF;
        
        NEW.bmi_score := score;
        NEW.bmi_category := category;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
Create trigger to auto-calculate BMI
CREATE TRIGGER trigger_calculate_bmi
BEFORE INSERT OR UPDATE ON BodyMeasurement
FOR EACH ROW
EXECUTE FUNCTION calculate_bmi_and_score();
CREATE TRIGGER trigger_sync_to_user
AFTER INSERT ON BodyMeasurement
FOR EACH ROW
EXECUTE FUNCTION sync_latest_measurement_to_user();
CREATE OR REPLACE FUNCTION sync_latest_measurement_to_user()
RETURNS TRIGGER AS $$
BEGIN
    -- Update User table with latest measurement
    UPDATE "User"
    SET 
        weight_kg = NEW.weight_kg,
        height_cm = NEW.height_cm
    WHERE user_id = NEW.user_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_chat_system.sql
CREATE TABLE IF NOT EXISTS ChatbotConversation (
    conversation_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
    title VARCHAR(200) DEFAULT 'New conversation',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS ChatbotMessage (
    message_id SERIAL PRIMARY KEY,
    conversation_id INT NOT NULL REFERENCES ChatbotConversation(conversation_id) ON DELETE CASCADE,
    sender VARCHAR(20) NOT NULL CHECK (sender IN ('user', 'bot')),
    message_text TEXT,
    image_url TEXT,
    nutrition_data JSONB, -- Stores analyzed nutrition data from food images
    is_approved BOOLEAN DEFAULT NULL, -- NULL=pending, TRUE=approved, FALSE=rejected
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS AdminConversation (
    admin_conversation_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'resolved', 'archived')),
    subject VARCHAR(200),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS AdminMessage (
    admin_message_id SERIAL PRIMARY KEY,
    admin_conversation_id INT NOT NULL REFERENCES AdminConversation(admin_conversation_id) ON DELETE CASCADE,
    sender_type VARCHAR(20) NOT NULL CHECK (sender_type IN ('user', 'admin')),
    sender_id INT NOT NULL, -- user_id or admin_id depending on sender_type
    message_text TEXT,
    image_url TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS NutritionAnalysis (
    analysis_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    image_url TEXT NOT NULL,
    food_name VARCHAR(200),
    confidence_score NUMERIC(3,2), -- 0.00 to 1.00
    nutrients JSONB NOT NULL, -- Array of {nutrient_id, nutrient_name, amount, unit}
    is_approved BOOLEAN DEFAULT NULL,
    approved_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE OR REPLACE FUNCTION update_conversation_timestamp() RETURNS TRIGGER AS $$
BEGIN
    IF TG_TABLE_NAME = 'ChatbotMessage' THEN
        UPDATE ChatbotConversation 
        SET updated_at = NOW() 
        WHERE conversation_id = NEW.conversation_id;
    ELSIF TG_TABLE_NAME = 'AdminMessage' THEN
        UPDATE AdminConversation 
        SET updated_at = NOW() 
        WHERE admin_conversation_id = NEW.admin_conversation_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_update_chatbot_conversation_timestamp
AFTER INSERT ON ChatbotMessage
FOR EACH ROW EXECUTE FUNCTION update_conversation_timestamp();
CREATE TRIGGER trg_update_admin_conversation_timestamp
AFTER INSERT ON AdminMessage
FOR EACH ROW EXECUTE FUNCTION update_conversation_timestamp();

-- Source: 2025_create_user_meal_tables.sql
CREATE TABLE IF NOT EXISTS user_meal_targets (
  id SERIAL PRIMARY KEY,
  user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
  target_date DATE NOT NULL DEFAULT CURRENT_DATE,
  meal_type VARCHAR(16) NOT NULL,
  target_kcal NUMERIC(10,2) DEFAULT 0,
  target_carbs NUMERIC(10,2) DEFAULT 0,
  target_protein NUMERIC(10,2) DEFAULT 0,
  target_fat NUMERIC(10,2) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE IF NOT EXISTS meal_entries (
  id SERIAL PRIMARY KEY,
  user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
  entry_date DATE NOT NULL DEFAULT CURRENT_DATE,
  meal_type VARCHAR(16) NOT NULL,
  food_id INTEGER,
  weight_g NUMERIC(10,2),
  kcal NUMERIC(10,2) DEFAULT 0,
  carbs NUMERIC(10,2) DEFAULT 0,
  protein NUMERIC(10,2) DEFAULT 0,
  fat NUMERIC(10,2) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE IF NOT EXISTS user_meal_summaries (
  id SERIAL PRIMARY KEY,
  user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
  summary_date DATE NOT NULL DEFAULT CURRENT_DATE,
  meal_type VARCHAR(16) NOT NULL,
  consumed_kcal NUMERIC(12,2) DEFAULT 0,
  consumed_carbs NUMERIC(12,2) DEFAULT 0,
  consumed_protein NUMERIC(12,2) DEFAULT 0,
  consumed_fat NUMERIC(12,2) DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE (user_id, summary_date, meal_type)
);

-- Source: 2025_dish_image_upload.sql
ALTER TABLE dish ADD COLUMN IF NOT EXISTS image_urls JSONB DEFAULT '[]';

-- Source: 2025_dish_management.sql
CREATE TABLE IF NOT EXISTS Dish (
    dish_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    vietnamese_name VARCHAR(200),  -- for bilingual support
    description TEXT,
    category VARCHAR(50),  -- 'noodle', 'rice', 'sandwich', 'soup', etc.
    serving_size_g NUMERIC(10,2) DEFAULT 100,  -- standard serving size in grams
    image_url TEXT,
    is_template BOOLEAN DEFAULT FALSE,  -- true for admin-created standard dishes
    is_public BOOLEAN DEFAULT TRUE,     -- false for user's private custom dishes
    created_by_user INT REFERENCES "User"(user_id) ON DELETE SET NULL,
    created_by_admin INT REFERENCES Admin(admin_id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    -- Constraints
    CHECK (serving_size_g > 0),
    CHECK (
        (created_by_user IS NOT NULL AND created_by_admin IS NULL) OR
        (created_by_user IS NULL AND created_by_admin IS NOT NULL)
    )
);
CREATE TABLE IF NOT EXISTS DishIngredient (
    dish_ingredient_id SERIAL PRIMARY KEY,
    dish_id INT NOT NULL REFERENCES Dish(dish_id) ON DELETE CASCADE,
    food_id INT NOT NULL REFERENCES Food(food_id) ON DELETE RESTRICT,
    weight_g NUMERIC(10,2) NOT NULL,  -- weight of this ingredient in the dish
    notes TEXT,  -- optional preparation notes for this ingredient
    display_order INT DEFAULT 0,  -- order to display ingredients in UI
    
    -- Constraints
    CHECK (weight_g > 0),
    UNIQUE(dish_id, food_id)  -- prevent duplicate ingredients in same dish
);
CREATE TABLE IF NOT EXISTS DishImage (
    dish_image_id SERIAL PRIMARY KEY,
    dish_id INT NOT NULL REFERENCES Dish(dish_id) ON DELETE CASCADE,
    image_url TEXT NOT NULL,
    image_type VARCHAR(20) DEFAULT 'photo',  -- 'photo', 'step', 'ingredient', etc.
    is_primary BOOLEAN DEFAULT FALSE,  -- primary image for thumbnails
    display_order INT DEFAULT 0,
    caption TEXT,
    uploaded_at TIMESTAMP DEFAULT NOW()
);
ALTER TABLE MealItem
    ADD COLUMN IF NOT EXISTS dish_id INT REFERENCES Dish(dish_id) ON DELETE SET NULL;
CREATE TABLE IF NOT EXISTS DishStatistics (
    stat_id SERIAL PRIMARY KEY,
    dish_id INT NOT NULL REFERENCES Dish(dish_id) ON DELETE CASCADE,
    total_times_logged INT DEFAULT 0,  -- how many times this dish was logged in meals
    unique_users_count INT DEFAULT 0,  -- how many different users logged this dish
    avg_rating NUMERIC(3,2),  -- average user rating (future feature)
    last_logged_at TIMESTAMP,
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(dish_id)
);
CREATE TABLE IF NOT EXISTS DishNutrient (
    dish_nutrient_id SERIAL PRIMARY KEY,
    dish_id INT NOT NULL REFERENCES Dish(dish_id) ON DELETE CASCADE,
    nutrient_id INT NOT NULL REFERENCES Nutrient(nutrient_id) ON DELETE CASCADE,
    amount_per_100g NUMERIC(12,6) DEFAULT 0,  -- nutrient amount per 100g of complete dish
    calculated_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(dish_id, nutrient_id)
);
CREATE OR REPLACE FUNCTION calculate_dish_nutrients(p_dish_id INT) RETURNS VOID AS $$
DECLARE
    v_total_weight NUMERIC;
    v_nutrient RECORD;
    v_amount NUMERIC;
BEGIN
    -- Get total weight of all ingredients in the dish
    SELECT SUM(weight_g) INTO v_total_weight
    FROM DishIngredient
    WHERE dish_id = p_dish_id;
    
    -- If no ingredients, clear all nutrients and return
    IF v_total_weight IS NULL OR v_total_weight = 0 THEN
        DELETE FROM DishNutrient WHERE dish_id = p_dish_id;
        RETURN;
    END IF;
    
    -- For each nutrient in the system, calculate the dish's content
    FOR v_nutrient IN SELECT nutrient_id FROM Nutrient LOOP
        -- Sum up contributions from all ingredients
        -- Formula: (ingredient_weight * nutrient_per_100g / 100) for each ingredient
        -- Then normalize to per 100g of total dish weight
        SELECT SUM(
            di.weight_g * COALESCE(fn.amount_per_100g, 0) / 100.0
        ) * 100.0 / v_total_weight
        INTO v_amount
        FROM DishIngredient di
        LEFT JOIN FoodNutrient fn ON fn.food_id = di.food_id 
            AND fn.nutrient_id = v_nutrient.nutrient_id
        WHERE di.dish_id = p_dish_id;
        
        -- Upsert into DishNutrient
        IF v_amount IS NOT NULL AND v_amount > 0 THEN
            INSERT INTO DishNutrient(dish_id, nutrient_id, amount_per_100g, calculated_at)
            VALUES (p_dish_id, v_nutrient.nutrient_id, ROUND(v_amount, 6), NOW())
            ON CONFLICT (dish_id, nutrient_id) DO UPDATE
            SET amount_per_100g = EXCLUDED.amount_per_100g,
                calculated_at = EXCLUDED.calculated_at;
        ELSE
            -- Remove zero/null nutrients to keep table clean
            DELETE FROM DishNutrient 
            WHERE dish_id = p_dish_id AND nutrient_id = v_nutrient.nutrient_id;
        END IF;
    END LOOP;
    
    -- Update dish's updated_at timestamp
    UPDATE Dish SET updated_at = NOW() WHERE dish_id = p_dish_id;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_dish_ingredient_changed
AFTER INSERT OR UPDATE OR DELETE ON DishIngredient
FOR EACH ROW EXECUTE FUNCTION trg_recalc_dish_nutrients();
CREATE TRIGGER trg_compute_mealitem_nutrients
BEFORE INSERT OR UPDATE ON MealItem
FOR EACH ROW EXECUTE FUNCTION compute_mealitem_nutrients();
CREATE TRIGGER trg_dish_statistics
AFTER INSERT ON MealItem
FOR EACH ROW EXECUTE FUNCTION update_dish_statistics();
CREATE OR REPLACE FUNCTION trg_recalc_dish_nutrients() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        PERFORM calculate_dish_nutrients(OLD.dish_id);
        RETURN OLD;
    ELSE
        PERFORM calculate_dish_nutrients(NEW.dish_id);
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION compute_mealitem_nutrients() RETURNS TRIGGER AS $$
DECLARE
    v_kcal NUMERIC := 0;
    v_protein NUMERIC := 0;
    v_fat NUMERIC := 0;
    v_carb NUMERIC := 0;
BEGIN
    -- Case 1: MealItem has a dish_id (using composed dish)
    IF NEW.dish_id IS NOT NULL THEN
        -- Get nutrients from DishNutrient table
        SELECT dn.amount_per_100g INTO v_kcal
        FROM DishNutrient dn
        JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id
        WHERE dn.dish_id = NEW.dish_id AND n.nutrient_code = 'ENERC_KCAL'
        LIMIT 1;
        
        SELECT dn.amount_per_100g INTO v_protein
        FROM DishNutrient dn
        JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id
        WHERE dn.dish_id = NEW.dish_id AND n.nutrient_code = 'PROCNT'
        LIMIT 1;
        
        SELECT dn.amount_per_100g INTO v_fat
        FROM DishNutrient dn
        JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id
        WHERE dn.dish_id = NEW.dish_id AND n.nutrient_code = 'FAT'
        LIMIT 1;
        
        SELECT dn.amount_per_100g INTO v_carb
        FROM DishNutrient dn
        JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id
        WHERE dn.dish_id = NEW.dish_id AND n.nutrient_code = 'CHOCDF'
        LIMIT 1;
        
        -- Fallback to name-based lookup if code not found
        IF v_kcal IS NULL OR v_kcal = 0 THEN
            SELECT dn.amount_per_100g INTO v_kcal 
            FROM DishNutrient dn 
            JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id 
            WHERE dn.dish_id = NEW.dish_id 
            AND (LOWER(n.name) LIKE '%calor%' OR LOWER(n.name) LIKE '%energy%')
            LIMIT 1;
        END IF;
        IF v_protein IS NULL OR v_protein = 0 THEN
            SELECT dn.amount_per_100g INTO v_protein 
            FROM DishNutrient dn 
            JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id 
            WHERE dn.dish_id = NEW.dish_id AND LOWER(n.name) LIKE '%protein%'
            LIMIT 1;
        END IF;
        IF v_fat IS NULL OR v_fat = 0 THEN
            SELECT dn.amount_per_100g INTO v_fat 
            FROM DishNutrient dn 
            JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id 
            WHERE dn.dish_id = NEW.dish_id AND LOWER(n.name) LIKE '%fat%'
            LIMIT 1;
        END IF;
        IF v_carb IS NULL OR v_carb = 0 THEN
            SELECT dn.amount_per_100g INTO v_carb 
            FROM DishNutrient dn 
            JOIN Nutrient n ON n.nutrient_id = dn.nutrient_id 
            WHERE dn.dish_id = NEW.dish_id 
            AND (LOWER(n.name) LIKE '%carb%' OR LOWER(n.name) LIKE '%carbo%')
            LIMIT 1;
        END IF;
    
    -- Case 2: MealItem has a food_id (traditional individual food)
    ELSIF NEW.food_id IS NOT NULL THEN
        -- Use existing food nutrient lookup (keep original logic)
        SELECT fn.amount_per_100g INTO v_kcal
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id AND n.nutrient_code = 'ENERC_KCAL'
        LIMIT 1;
        
        SELECT fn.amount_per_100g INTO v_protein
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id AND n.nutrient_code = 'PROCNT'
        LIMIT 1;
        
        SELECT fn.amount_per_100g INTO v_fat
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id AND n.nutrient_code = 'FAT'
        LIMIT 1;
        
        SELECT fn.amount_per_100g INTO v_carb
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id AND n.nutrient_code = 'CHOCDF'
        LIMIT 1;
        
        -- Fallback name-based lookup
        IF v_kcal IS NULL OR v_kcal = 0 THEN
            SELECT fn.amount_per_100g INTO v_kcal 
            FROM FoodNutrient fn 
            JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id 
            WHERE fn.food_id = NEW.food_id 
            AND (LOWER(n.name) LIKE '%calor%' OR LOWER(n.name) LIKE '%energy%')
            LIMIT 1;
        END IF;
        IF v_protein IS NULL OR v_protein = 0 THEN
            SELECT fn.amount_per_100g INTO v_protein 
            FROM FoodNutrient fn 
            JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id 
            WHERE fn.food_id = NEW.food_id AND LOWER(n.name) LIKE '%protein%'
            LIMIT 1;
        END IF;
        IF v_fat IS NULL OR v_fat = 0 THEN
            SELECT fn.amount_per_100g INTO v_fat 
            FROM FoodNutrient fn 
            JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id 
            WHERE fn.food_id = NEW.food_id AND LOWER(n.name) LIKE '%fat%'
            LIMIT 1;
        END IF;
        IF v_carb IS NULL OR v_carb = 0 THEN
            SELECT fn.amount_per_100g INTO v_carb 
            FROM FoodNutrient fn 
            JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id 
            WHERE fn.food_id = NEW.food_id 
            AND (LOWER(n.name) LIKE '%carb%' OR LOWER(n.name) LIKE '%carbo%')
            LIMIT 1;
        END IF;
    
    -- Case 3: Neither food_id nor dish_id provided (should not happen due to constraint)
    ELSE
        NEW.calories := 0;
        NEW.protein := 0;
        NEW.fat := 0;
        NEW.carbs := 0;
        RETURN NEW;
    END IF;
    
    -- Null-safe coalescing
    v_kcal := COALESCE(v_kcal, 0);
    v_protein := COALESCE(v_protein, 0);
    v_fat := COALESCE(v_fat, 0);
    v_carb := COALESCE(v_carb, 0);
    
    -- Compute per item (weight_g is serving weight)
    NEW.calories := ROUND((v_kcal * NEW.weight_g) / 100.0, 2);
    NEW.protein := ROUND((v_protein * NEW.weight_g) / 100.0, 2);
    NEW.fat := ROUND((v_fat * NEW.weight_g) / 100.0, 2);
    NEW.carbs := ROUND((v_carb * NEW.weight_g) / 100.0, 2);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION update_dish_statistics() RETURNS TRIGGER AS $$
DECLARE
    v_dish_id INT;
    v_user_id INT;
BEGIN
    IF TG_OP = 'INSERT' AND NEW.dish_id IS NOT NULL THEN
        v_dish_id := NEW.dish_id;
        SELECT user_id INTO v_user_id FROM Meal WHERE meal_id = NEW.meal_id;
        
        -- Upsert statistics
        INSERT INTO DishStatistics(dish_id, total_times_logged, unique_users_count, last_logged_at)
        VALUES (v_dish_id, 1, 1, NOW())
        ON CONFLICT (dish_id) DO UPDATE
        SET total_times_logged = DishStatistics.total_times_logged + 1,
            last_logged_at = NOW(),
            unique_users_count = (
                SELECT COUNT(DISTINCT m.user_id)
                FROM MealItem mi
                JOIN Meal m ON m.meal_id = mi.meal_id
                WHERE mi.dish_id = v_dish_id
            ),
            updated_at = NOW();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_dish_total_weight(p_dish_id INT) RETURNS NUMERIC AS $$
DECLARE
    v_total NUMERIC;
BEGIN
    SELECT SUM(weight_g) INTO v_total FROM DishIngredient WHERE dish_id = p_dish_id;
    RETURN COALESCE(v_total, 0);
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_dish_ingredient_count(p_dish_id INT) RETURNS INT AS $$
DECLARE
    v_count INT;
BEGIN
    SELECT COUNT(*) INTO v_count FROM DishIngredient WHERE dish_id = p_dish_id;
    RETURN COALESCE(v_count, 0);
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_user_custom_dish_count(p_user_id INT) RETURNS INT AS $$
DECLARE
    v_count INT;
BEGIN
    SELECT COUNT(*) INTO v_count FROM Dish WHERE created_by_user = p_user_id;
    RETURN COALESCE(v_count, 0);
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_dish_notifications.sql
CREATE TABLE IF NOT EXISTS dishnotification (
    notification_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES userprofile(user_id) ON DELETE CASCADE,
    dish_id INTEGER REFERENCES dish(dish_id) ON DELETE CASCADE,
    notification_type VARCHAR(50) NOT NULL, -- 'dish_created', 'dish_approved', 'dish_rejected', 'dish_popular'
    title VARCHAR(200) NOT NULL,
    message TEXT NOT NULL,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP
);
CREATE OR REPLACE FUNCTION notify_dish_created()
RETURNS TRIGGER AS $$
BEGIN
    -- Notify the creator
    IF NEW.created_by_user IS NOT NULL THEN
        INSERT INTO dishnotification (
            user_id,
            dish_id,
            notification_type,
            title,
            message
        ) VALUES (
            NEW.created_by_user,
            NEW.dish_id,
            'dish_created',
            'Món ăn đã được tạo thành công',
            FORMAT('Món "%s" của bạn đã được tạo thành công! Món ăn đang chờ phê duyệt từ quản trị viên.', COALESCE(NEW.vietnamese_name, NEW.name))
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
Create triggers
DROP TRIGGER IF EXISTS trg_notify_dish_created ON dish;
CREATE TRIGGER trg_notify_dish_created
    AFTER INSERT ON dish
    FOR EACH ROW
    WHEN (NEW.created_by_user IS NOT NULL AND NEW.is_template = FALSE)
    EXECUTE FUNCTION notify_dish_created();
CREATE TRIGGER trg_notify_dish_approved
    AFTER UPDATE ON dish
    FOR EACH ROW
    WHEN (NEW.created_by_user IS NOT NULL)
    EXECUTE FUNCTION notify_dish_approved();
CREATE TRIGGER trg_notify_dish_popular
    AFTER UPDATE ON dishstatistics
    FOR EACH ROW
    EXECUTE FUNCTION notify_dish_popular();
CREATE OR REPLACE FUNCTION notify_dish_approved()
RETURNS TRIGGER AS $$
BEGIN
    -- When dish becomes public (approved)
    IF NEW.is_public = TRUE AND OLD.is_public = FALSE AND NEW.created_by_user IS NOT NULL THEN
        INSERT INTO dishnotification (
            user_id,
            dish_id,
            notification_type,
            title,
            message
        ) VALUES (
            NEW.created_by_user,
            NEW.dish_id,
            'dish_approved',
            'Món ăn đã được phê duyệt! 🎉',
            FORMAT('Chúc mừng! Món "%s" của bạn đã được phê duyệt và hiện đã công khai cho mọi người sử dụng.', COALESCE(NEW.vietnamese_name, NEW.name))
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION notify_dish_popular()
RETURNS TRIGGER AS $$
DECLARE
    v_dish_name VARCHAR(200);
    v_user_id INTEGER;
BEGIN
    -- When dish reaches 10 times logged
    IF NEW.total_times_logged >= 10 AND OLD.total_times_logged < 10 THEN
        SELECT COALESCE(vietnamese_name, name), created_by_user INTO v_dish_name, v_user_id
        FROM dish WHERE dish_id = NEW.dish_id;
        
        IF v_user_id IS NOT NULL THEN
            INSERT INTO dishnotification (
                user_id,
                dish_id,
                notification_type,
                title,
                message
            ) VALUES (
                v_user_id,
                NEW.dish_id,
                'dish_popular',
                'Món ăn của bạn đang được yêu thích! ⭐',
                FORMAT('Món "%s" của bạn đã được ghi nhận %s lần! Cảm ơn bạn đã chia sẻ công thức tuyệt vời.', 
                       v_dish_name, NEW.total_times_logged)
            );
        END IF;
    END IF;
    
    -- Milestone notifications: 50, 100, 500 times
    IF NEW.total_times_logged >= 50 AND OLD.total_times_logged < 50 THEN
        SELECT COALESCE(vietnamese_name, name), created_by_user INTO v_dish_name, v_user_id
        FROM dish WHERE dish_id = NEW.dish_id;
        
        IF v_user_id IS NOT NULL THEN
            INSERT INTO dishnotification (
                user_id,
                dish_id,
                notification_type,
                title,
                message
            ) VALUES (
                v_user_id,
                NEW.dish_id,
                'dish_popular',
                'Món ăn siêu phổ biến! 🌟',
                FORMAT('Wow! Món "%s" đã đạt %s lần ghi nhận. Bạn thật tuyệt vời!', 
                       v_dish_name, NEW.total_times_logged)
            );
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_enhance_food_management.sql
ALTER TABLE Food 
    ADD COLUMN IF NOT EXISTS description TEXT,
    ADD COLUMN IF NOT EXISTS serving_size_g NUMERIC(10,2) DEFAULT 100.00,
    ADD COLUMN IF NOT EXISTS is_verified BOOLEAN DEFAULT FALSE,
    ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT TRUE,
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS created_by_user INT REFERENCES "User"(user_id) ON DELETE SET NULL;
Create function to update Food updated_at timestamp
CREATE OR REPLACE FUNCTION update_food_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
Create trigger for Food timestamp
DROP TRIGGER IF EXISTS trg_update_food_timestamp ON Food;
CREATE TRIGGER trg_update_food_timestamp
    BEFORE UPDATE ON Food
    FOR EACH ROW
    EXECUTE FUNCTION update_food_timestamp();
CREATE TABLE IF NOT EXISTS FoodCategory (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    icon VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Source: 2025_health_condition_system.sql
CREATE TABLE HealthCondition (
    condition_id SERIAL PRIMARY KEY,
    name_vi VARCHAR(200) NOT NULL UNIQUE,
    name_en VARCHAR(200) NOT NULL,
    category VARCHAR(100),                    -- Loại bệnh: Tim mạch, Chuyển hóa, Tiêu hóa...
    description TEXT,                         -- Mô tả bệnh
    causes TEXT,                              -- Nguyên nhân
    image_url TEXT,                           -- URL hình ảnh minh họa
    treatment_duration_reference VARCHAR(100), -- Thời gian điều trị tham khảo (admin nhập)
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS UserHealthCondition (
    user_condition_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    condition_id INT REFERENCES HealthCondition(condition_id) ON DELETE CASCADE,
    diagnosed_date DATE DEFAULT CURRENT_DATE,
    treatment_start_date DATE DEFAULT CURRENT_DATE,
    treatment_end_date DATE,                  -- User tự thiết lập
    treatment_duration_days INT,              -- Số ngày điều trị (tính từ start đến end)
    status VARCHAR(20) DEFAULT 'active',      -- active, completed, paused
    notes TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, condition_id, treatment_start_date)
);
CREATE TABLE IF NOT EXISTS MedicationSchedule (
    medication_id SERIAL PRIMARY KEY,
    user_condition_id INT REFERENCES UserHealthCondition(user_condition_id) ON DELETE CASCADE,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    medication_times TEXT[],                  -- ['07:00', '12:00', '19:00'] - giờ uống thuốc
    notes TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS MedicationLog (
    log_id SERIAL PRIMARY KEY,
    user_condition_id INT REFERENCES UserHealthCondition(user_condition_id) ON DELETE CASCADE,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    medication_date DATE NOT NULL,
    medication_time TIME NOT NULL,
    taken_at TIMESTAMP,                       -- Thời điểm thực tế đánh dấu đã uống
    status VARCHAR(20) DEFAULT 'pending',     -- pending, taken, skipped
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_condition_id, medication_date, medication_time)
);
CREATE TABLE ConditionNutrientEffect (
    effect_id SERIAL PRIMARY KEY,
    condition_id INT REFERENCES HealthCondition(condition_id) ON DELETE CASCADE,
    nutrient_id INT REFERENCES Nutrient(nutrient_id) ON DELETE CASCADE,
    effect_type VARCHAR(10) CHECK (effect_type IN ('increase', 'decrease')),
    adjustment_percent NUMERIC(5,2) NOT NULL, -- % điều chỉnh (+40, -20...)
    notes TEXT,
    UNIQUE(condition_id, nutrient_id)
);
CREATE TABLE ConditionFoodRecommendation (
    recommendation_id SERIAL PRIMARY KEY,
    condition_id INT REFERENCES HealthCondition(condition_id) ON DELETE CASCADE,
    food_id INT REFERENCES Food(food_id) ON DELETE CASCADE,
    recommendation_type VARCHAR(10) DEFAULT 'avoid' CHECK (recommendation_type IN ('recommend', 'avoid')),
    notes TEXT,
    UNIQUE(condition_id, food_id)
);
CREATE TABLE ConditionEffectLog (
    log_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    condition_id INT REFERENCES HealthCondition(condition_id),
    nutrient_id INT REFERENCES Nutrient(nutrient_id),
    effect_type VARCHAR(10),
    adjustment_percent NUMERIC(5,2),
    original_rda NUMERIC(10,2),
    adjusted_rda NUMERIC(10,2),
    applied_at TIMESTAMP DEFAULT NOW()
);
CREATE OR REPLACE FUNCTION calculate_treatment_duration() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.treatment_end_date IS NOT NULL AND NEW.treatment_start_date IS NOT NULL THEN
        NEW.treatment_duration_days := NEW.treatment_end_date - NEW.treatment_start_date;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_calculate_treatment_duration
    BEFORE INSERT OR UPDATE ON UserHealthCondition
    FOR EACH ROW
    EXECUTE FUNCTION calculate_treatment_duration();

-- Source: 2025_meal_history_and_features.sql
ALTER TABLE Meal 
ADD COLUMN IF NOT EXISTS is_favorite BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS notes TEXT;
ALTER TABLE MealItem
ADD COLUMN IF NOT EXISTS quick_add_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_eaten_at TIMESTAMP;
CREATE TABLE IF NOT EXISTS PortionSize (
    portion_id SERIAL PRIMARY KEY,
    food_id INTEGER REFERENCES Food(food_id) ON DELETE CASCADE,
    portion_name VARCHAR(100) NOT NULL, -- e.g., "1 medium apple", "1 cup cooked rice"
    portion_name_vi VARCHAR(100), -- Vietnamese translation
    weight_g DECIMAL(10, 2) NOT NULL,
    is_common BOOLEAN DEFAULT false, -- Mark commonly used portions
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS Recipe (
    recipe_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES "User"(user_id) ON DELETE CASCADE,
    recipe_name VARCHAR(200) NOT NULL,
    description TEXT,
    servings INTEGER DEFAULT 1,
    prep_time_minutes INTEGER,
    cook_time_minutes INTEGER,
    instructions TEXT,
    image_url TEXT,
    is_public BOOLEAN DEFAULT false, -- Allow sharing recipes
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS RecipeIngredient (
    recipe_ingredient_id SERIAL PRIMARY KEY,
    recipe_id INTEGER REFERENCES Recipe(recipe_id) ON DELETE CASCADE,
    food_id INTEGER REFERENCES Food(food_id) ON DELETE CASCADE,
    weight_g DECIMAL(10, 2) NOT NULL,
    ingredient_order INTEGER DEFAULT 0,
    notes TEXT, -- e.g., "chopped", "diced"
    UNIQUE(recipe_id, food_id)
);
CREATE OR REPLACE FUNCTION update_recipe_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER recipe_update_timestamp
    BEFORE UPDATE ON Recipe
    FOR EACH ROW
    EXECUTE FUNCTION update_recipe_timestamp();
CREATE TABLE IF NOT EXISTS MealTemplate (
    template_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES "User"(user_id) ON DELETE CASCADE,
    template_name VARCHAR(200) NOT NULL,
    description TEXT,
    meal_type VARCHAR(20) CHECK (meal_type IN ('breakfast', 'lunch', 'dinner', 'snack')),
    is_favorite BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS MealTemplateItem (
    template_item_id SERIAL PRIMARY KEY,
    template_id INTEGER REFERENCES MealTemplate(template_id) ON DELETE CASCADE,
    food_id INTEGER REFERENCES Food(food_id) ON DELETE CASCADE,
    weight_g DECIMAL(10, 2) NOT NULL,
    item_order INTEGER DEFAULT 0
);
CREATE TRIGGER template_update_timestamp
    BEFORE UPDATE ON MealTemplate
    FOR EACH ROW
    EXECUTE FUNCTION update_recipe_timestamp();
ALTER TABLE Meal
ADD COLUMN IF NOT EXISTS photo_url TEXT,
ADD COLUMN IF NOT EXISTS photo_recognition_data JSONB;

-- Source: 2025_rbac_permissions.sql
CREATE TABLE IF NOT EXISTS permission (
    permission_id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    resource VARCHAR(50) NOT NULL, -- users, foods, dishes, analytics, etc.
    action VARCHAR(50) NOT NULL,   -- create, read, update, delete, manage
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS rolepermission (
    role_permission_id SERIAL PRIMARY KEY,
    role_name VARCHAR(50) REFERENCES role(role_name) ON DELETE CASCADE,
    permission_id INTEGER REFERENCES permission(permission_id) ON DELETE CASCADE,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(role_name, permission_id)
);
Create function to check permission
CREATE OR REPLACE FUNCTION has_permission(
    p_admin_id INTEGER,
    p_permission_name VARCHAR(100)
) RETURNS BOOLEAN AS $$
DECLARE
    v_has_permission BOOLEAN;
BEGIN
    SELECT EXISTS(
        SELECT 1
        FROM adminrole ar
        JOIN rolepermission rp ON ar.role_name = rp.role_name
        JOIN permission p ON rp.permission_id = p.permission_id
        WHERE ar.admin_id = p_admin_id
        AND p.name = p_permission_name
    ) INTO v_has_permission;
    
    RETURN v_has_permission;
END;
$$ LANGUAGE plpgsql;
Create function to get admin permissions
CREATE OR REPLACE FUNCTION get_admin_permissions(p_admin_id INTEGER)
RETURNS TABLE(
    permission_name VARCHAR(100),
    permission_description TEXT,
    resource VARCHAR(50),
    action VARCHAR(50)
) AS $$
BEGIN
    RETURN QUERY
    SELECT DISTINCT p.name, p.description, p.resource, p.action
    FROM adminrole ar
    JOIN rolepermission rp ON ar.role_name = rp.role_name
    JOIN permission p ON rp.permission_id = p.permission_id
    WHERE ar.admin_id = p_admin_id
    ORDER BY p.resource, p.action;
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_security_features.sql
CREATE TABLE IF NOT EXISTS UserSecurity (
  user_id INT PRIMARY KEY REFERENCES "User"(user_id) ON DELETE CASCADE,
  twofa_enabled BOOLEAN NOT NULL DEFAULT FALSE,
  twofa_secret TEXT,
  lock_threshold INT NOT NULL DEFAULT 5,
  failed_attempts INT NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TABLE IF NOT EXISTS PasswordChangeCode (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
  code VARCHAR(12) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  used_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ NOT NULL
);

-- Source: 2025_trim_food_and_translate.sql
ALTER TABLE "Food" ADD COLUMN IF NOT EXISTS name_vi TEXT;

-- Source: 2025_update_nutrient_tracking_add_amino_fiber_fat.sql
CREATE OR REPLACE FUNCTION calculate_daily_nutrient_intake(
    p_user_id INT,
    p_date DATE
) RETURNS TABLE(
    nutrient_type VARCHAR(20),
    nutrient_id INT,
    nutrient_code VARCHAR(50),
    nutrient_name VARCHAR(100),
    current_amount NUMERIC,
    target_amount NUMERIC,
    unit VARCHAR(20),
    percentage NUMERIC
) AS $$
BEGIN
    -- Calculate nutrient intake from meals for all nutrient types
    RETURN QUERY
    WITH meal_items_today AS (
        SELECT mi.food_id, mi.weight_g
        FROM MealItem mi
        JOIN Meal m ON m.meal_id = mi.meal_id
        WHERE m.user_id = p_user_id AND m.meal_date = p_date
    ),
    vitamin_intake AS (
        SELECT 
            'vitamin'::VARCHAR(20) as nutrient_type,
            v.vitamin_id::INT as nutrient_id,
            v.code as nutrient_code,
            v.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(uvr.recommended, v.recommended_daily::NUMERIC, 0) as target_amount,
            v.unit,
            CASE 
                WHEN COALESCE(uvr.recommended, v.recommended_daily::NUMERIC, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(uvr.recommended, v.recommended_daily::NUMERIC, 1)) * 100
                ELSE 0 
            END as percentage
        FROM Vitamin v
        LEFT JOIN UserVitaminRequirement uvr ON uvr.vitamin_id = v.vitamin_id AND uvr.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(v.code)
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY v.vitamin_id, v.code, v.name, v.unit, v.recommended_daily, uvr.recommended
    ),
    mineral_intake AS (
        SELECT 
            'mineral'::VARCHAR(20) as nutrient_type,
            m.mineral_id::INT as nutrient_id,
            m.code as nutrient_code,
            m.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(umr.recommended, m.recommended_daily::NUMERIC, 0) as target_amount,
            m.unit,
            CASE 
                WHEN COALESCE(umr.recommended, m.recommended_daily::NUMERIC, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(umr.recommended, m.recommended_daily::NUMERIC, 1)) * 100
                ELSE 0 
            END as percentage
        FROM Mineral m
        LEFT JOIN UserMineralRequirement umr ON umr.mineral_id = m.mineral_id AND umr.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(REPLACE(m.code, 'MIN_', ''))
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY m.mineral_id, m.code, m.name, m.unit, m.recommended_daily, umr.recommended
    ),
    amino_acid_intake AS (
        SELECT 
            'amino_acid'::VARCHAR(20) as nutrient_type,
            aa.amino_acid_id::INT as nutrient_id,
            aa.code as nutrient_code,
            aa.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(uar.recommended, 0) as target_amount,
            'mg'::VARCHAR(20) as unit,
            CASE 
                WHEN COALESCE(uar.recommended, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(uar.recommended, 1)) * 100
                ELSE 0 
            END as percentage
        FROM AminoAcid aa
        LEFT JOIN UserAminoRequirement uar ON uar.amino_acid_id = aa.amino_acid_id AND uar.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(aa.code)
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY aa.amino_acid_id, aa.code, aa.name, uar.recommended
    ),
    fiber_intake AS (
        SELECT 
            'fiber'::VARCHAR(20) as nutrient_type,
            f.fiber_id::INT as nutrient_id,
            f.code as nutrient_code,
            f.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(ufr.recommended, 0) as target_amount,
            f.unit,
            CASE 
                WHEN COALESCE(ufr.recommended, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(ufr.recommended, 1)) * 100
                ELSE 0 
            END as percentage
        FROM Fiber f
        LEFT JOIN UserFiberRequirement ufr ON ufr.fiber_id = f.fiber_id AND ufr.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(f.code)
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY f.fiber_id, f.code, f.name, f.unit, f.recommended_daily, ufr.recommended
    ),
    fatty_acid_intake AS (
        SELECT 
            'fatty_acid'::VARCHAR(20) as nutrient_type,
            fa.fatty_acid_id::INT as nutrient_id,
            fa.code as nutrient_code,
            fa.name as nutrient_name,
            COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) as current_amount,
            COALESCE(ufar.recommended, 0) as target_amount,
            fa.unit,
            CASE 
                WHEN COALESCE(ufar.recommended, 0) > 0 
                THEN (COALESCE(SUM(fn.amount_per_100g * mit.weight_g / 100.0), 0) / COALESCE(ufar.recommended, 1)) * 100
                ELSE 0 
            END as percentage
        FROM FattyAcid fa
        LEFT JOIN UserFattyAcidRequirement ufar ON ufar.fatty_acid_id = fa.fatty_acid_id AND ufar.user_id = p_user_id
        LEFT JOIN Nutrient n ON UPPER(n.nutrient_code) = UPPER(fa.code)
        LEFT JOIN FoodNutrient fn ON fn.nutrient_id = n.nutrient_id
        LEFT JOIN meal_items_today mit ON mit.food_id = fn.food_id
        GROUP BY fa.fatty_acid_id, fa.code, fa.name, fa.unit, fa.recommended_daily, ufar.recommended
    )
    SELECT * FROM vitamin_intake
    UNION ALL
    SELECT * FROM mineral_intake
    UNION ALL
    SELECT * FROM amino_acid_intake
    UNION ALL
    SELECT * FROM fiber_intake
    UNION ALL
    SELECT * FROM fatty_acid_intake;
END;
$$ LANGUAGE plpgsql;

-- Source: 2025_user_blocking.sql
ALTER TABLE "User"
    ADD COLUMN IF NOT EXISTS last_login TIMESTAMPTZ;
CREATE TABLE IF NOT EXISTS user_account_status (
    user_id INT PRIMARY KEY REFERENCES "User"(user_id) ON DELETE CASCADE,
    is_blocked BOOLEAN NOT NULL DEFAULT FALSE,
    blocked_reason TEXT,
    blocked_at TIMESTAMPTZ,
    blocked_by_admin INT REFERENCES Admin(admin_id) ON DELETE SET NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TABLE IF NOT EXISTS user_block_event (
    block_event_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    event_type VARCHAR(20) NOT NULL CHECK (event_type IN ('block','unblock')),
    reason TEXT,
    admin_id INT REFERENCES Admin(admin_id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TABLE IF NOT EXISTS user_unblock_request (
    request_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending','approved','rejected','cancelled')),
    message TEXT, -- user provided reason / appeal
    admin_response TEXT, -- admin notes on decision
    decided_at TIMESTAMPTZ,
    decided_by_admin INT REFERENCES Admin(admin_id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Source: Insert.sql

-- Source: fix_calculate_daily_nutrient_function.sql
CREATE OR REPLACE FUNCTION calculate_daily_nutrient_intake(
    p_user_id INT,
    p_date DATE
) RETURNS TABLE(
    nutrient_type VARCHAR(20),
    nutrient_id INT,
    nutrient_name VARCHAR(100),
    total_amount NUMERIC(10,3),
    target_amount NUMERIC(10,3),
    unit VARCHAR(20),
    percent_of_target NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    -- Vitamins from meals
    WITH user_meals AS (
        SELECT 
            mi.food_id,
            mi.weight_g,
            mi.dish_id
        FROM Meal m
        JOIN MealItem mi ON m.meal_id = mi.meal_id
        WHERE m.user_id = p_user_id 
        AND m.meal_date = p_date
    ),
    vitamin_intake AS (
        SELECT 
            v.vitamin_id,
            v.name,
            v.unit,
            COALESCE(SUM(
                CASE 
                    WHEN um.food_id IS NOT NULL THEN 
                        (fn.amount_per_100g * um.weight_g / 100.0)
                    ELSE 0
                END
            ), 0) as total_consumed
        FROM Vitamin v
        LEFT JOIN nutrientmapping nm ON v.code = nm.nutrient_code AND nm.nutrient_type = 'vitamin'
        LEFT JOIN FoodNutrient fn ON nm.nutrient_id = fn.nutrient_id
        LEFT JOIN user_meals um ON fn.food_id = um.food_id
        GROUP BY v.vitamin_id, v.name, v.unit
    )
    SELECT 
        'vitamin'::VARCHAR(20) as nutrient_type,
        vi.vitamin_id as nutrient_id,
        vi.name::VARCHAR(100) as nutrient_name,
        vi.total_consumed::NUMERIC(10,3) as total_amount,
        COALESCE(vrda.base_value, 0)::NUMERIC(10,3) as target_amount,
        COALESCE(vrda.unit, vi.unit, 'mg')::VARCHAR(20) as unit,
        CASE 
            WHEN COALESCE(vrda.base_value, 0) > 0 THEN 
                (vi.total_consumed / vrda.base_value * 100)::NUMERIC(5,2)
            ELSE 0::NUMERIC(5,2)
        END as percent_of_target
    FROM vitamin_intake vi
    LEFT JOIN VitaminRDA vrda ON vi.vitamin_id = vrda.vitamin_id
    
    UNION ALL
    
    -- Minerals from meals
    SELECT 
        'mineral'::VARCHAR(20),
        mi.mineral_id,
        mi.name::VARCHAR(100),
        mi.total_consumed::NUMERIC(10,3),
        COALESCE(mrda.base_value, 0)::NUMERIC(10,3),
        COALESCE(mrda.unit, mi.unit, 'mg')::VARCHAR(20),
        CASE 
            WHEN COALESCE(mrda.base_value, 0) > 0 THEN 
                (mi.total_consumed / mrda.base_value * 100)::NUMERIC(5,2)
            ELSE 0::NUMERIC(5,2)
        END
    FROM (
        SELECT 
            min.mineral_id,
            min.name,
            min.unit,
            COALESCE(SUM(
                CASE 
                    WHEN um.food_id IS NOT NULL THEN 
                        (fn.amount_per_100g * um.weight_g / 100.0)
                    ELSE 0
                END
            ), 0) as total_consumed
        FROM Mineral min
        LEFT JOIN nutrientmapping nm ON min.code = nm.nutrient_code AND nm.nutrient_type = 'mineral'
        LEFT JOIN FoodNutrient fn ON nm.nutrient_id = fn.nutrient_id
        LEFT JOIN (
            SELECT 
                mi2.food_id,
                mi2.weight_g,
                mi2.dish_id
            FROM Meal m2
            JOIN MealItem mi2 ON m2.meal_id = mi2.meal_id
            WHERE m2.user_id = p_user_id 
            AND m2.meal_date = p_date
        ) um ON fn.food_id = um.food_id
        GROUP BY min.mineral_id, min.name, min.unit
    ) mi
    LEFT JOIN MineralRDA mrda ON mi.mineral_id = mrda.mineral_id;
        SELECT 
            min.mineral_id,
            min.name,
            min.unit,
            COALESCE(SUM(
                CASE 
                    WHEN um.food_id IS NOT NULL THEN 
                        (fn.amount_per_100g * um.weight_g / 100.0)
        
END;
$$ LANGUAGE plpgsql;

-- Source: fix_calculate_daily_nutrient_function_final.sql
CREATE OR REPLACE FUNCTION calculate_daily_nutrient_intake(
    p_user_id INT,
    p_date DATE
) RETURNS TABLE(
    nutrient_type VARCHAR(20),
    nutrient_id INT,
    nutrient_name VARCHAR(100),
    total_amount NUMERIC(10,3),
    target_amount NUMERIC(10,3),
    unit VARCHAR(20),
    percent_of_target NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    -- Vitamins with RDA targets
    SELECT 
        'vitamin'::VARCHAR(20),
        v.vitamin_id,
        v.name::VARCHAR(100),
        0::NUMERIC(10,3) as total_amount,
        COALESCE(vrda.rda_value, v.recommended_daily, 0)::NUMERIC(10,3),
        COALESCE(vrda.unit, v.unit, 'mg')::VARCHAR(20),
        0::NUMERIC(5,2) as percent_of_target
    FROM Vitamin v
    LEFT JOIN VitaminRDA vrda ON v.vitamin_id = vrda.vitamin_id
    
    UNION ALL
    
    -- Minerals with RDA targets
    SELECT 
        'mineral'::VARCHAR(20),
        m.mineral_id,
        m.name::VARCHAR(100),
        0::NUMERIC(10,3),
        COALESCE(mrda.rda_value, m.recommended_daily, 0)::NUMERIC(10,3),
        COALESCE(mrda.unit, m.unit, 'mg')::VARCHAR(20),
        0::NUMERIC(5,2)
    FROM Mineral m
    LEFT JOIN MineralRDA mrda ON m.mineral_id = mrda.mineral_id;
END;
$$ LANGUAGE plpgsql;

-- Source: fix_calculate_daily_nutrient_function_simple.sql
CREATE OR REPLACE FUNCTION calculate_daily_nutrient_intake(
    p_user_id INT,
    p_date DATE
) RETURNS TABLE(
    nutrient_type VARCHAR(20),
    nutrient_id INT,
    nutrient_name VARCHAR(100),
    total_amount NUMERIC(10,3),
    target_amount NUMERIC(10,3),
    unit VARCHAR(20),
    percent_of_target NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    -- Vitamins with RDA targets
    SELECT 
        'vitamin'::VARCHAR(20),
        v.vitamin_id,
        v.name::VARCHAR(100),
        0::NUMERIC(10,3) as total_amount,
        COALESCE(vrda.base_value, v.recommended_daily, 0)::NUMERIC(10,3),
        COALESCE(vrda.unit, v.unit, 'mg')::VARCHAR(20),
        0::NUMERIC(5,2) as percent_of_target
    FROM Vitamin v
    LEFT JOIN VitaminRDA vrda ON v.vitamin_id = vrda.vitamin_id
    
    UNION ALL
    
    -- Minerals with RDA targets
    SELECT 
        'mineral'::VARCHAR(20),
        m.mineral_id,
        m.name::VARCHAR(100),
        0::NUMERIC(10,3),
        COALESCE(mrda.base_value, m.recommended_daily, 0)::NUMERIC(10,3),
        COALESCE(mrda.unit, m.unit, 'mg')::VARCHAR(20),
        0::NUMERIC(5,2)
    FROM Mineral m
    LEFT JOIN MineralRDA mrda ON m.mineral_id = mrda.mineral_id;
END;
$$ LANGUAGE plpgsql;

-- Source: fix_calculate_daily_nutrient_function_v2.sql
CREATE OR REPLACE FUNCTION calculate_daily_nutrient_intake(
    p_user_id INT,
    p_date DATE
) RETURNS TABLE(
    nutrient_type VARCHAR(20),
    nutrient_id INT,
    nutrient_name VARCHAR(100),
    total_amount NUMERIC(10,3),
    target_amount NUMERIC(10,3),
    unit VARCHAR(20),
    percent_of_target NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    -- Vitamins from meals
    WITH user_meals AS (
        SELECT 
            mi.food_id,
            mi.weight_g
        FROM Meal m
        JOIN MealItem mi ON m.meal_id = mi.meal_id
        WHERE m.user_id = p_user_id 
        AND m.meal_date = p_date
    ),
    vitamin_intake AS (
        SELECT 
            v.vitamin_id,
            v.name,
            v.unit,
            COALESCE(SUM(
                (fn.amount_per_100g * um.weight_g / 100.0)
            ), 0) as total_consumed
        FROM Vitamin v
        LEFT JOIN nutrientmapping nm ON v.code = nm.nutrient_code AND nm.nutrient_type = 'vitamin'
        LEFT JOIN FoodNutrient fn ON nm.nutrient_id = fn.nutrient_id
        LEFT JOIN user_meals um ON fn.food_id = um.food_id
        GROUP BY v.vitamin_id, v.name, v.unit
    )
    SELECT 
        'vitamin'::VARCHAR(20),
        vi.vitamin_id,
        vi.name::VARCHAR(100),
        vi.total_consumed::NUMERIC(10,3),
        COALESCE(vrda.base_value, 0)::NUMERIC(10,3),
        COALESCE(vrda.unit, vi.unit, 'mg')::VARCHAR(20),
        CASE 
            WHEN COALESCE(vrda.base_value, 0) > 0 THEN 
                (vi.total_consumed / vrda.base_value * 100)::NUMERIC(5,2)
            ELSE 0::NUMERIC(5,2)
        END
    FROM vitamin_intake vi
    LEFT JOIN VitaminRDA vrda ON vi.vitamin_id = vrda.vitamin_id
    
    UNION ALL
    
    -- Minerals from meals
    SELECT 
        'mineral'::VARCHAR(20),
        mi.mineral_id,
        mi.name::VARCHAR(100),
        mi.total_consumed::NUMERIC(10,3),
        COALESCE(mrda.base_value, 0)::NUMERIC(10,3),
        COALESCE(mrda.unit, mi.unit, 'mg')::VARCHAR(20),
        CASE 
            WHEN COALESCE(mrda.base_value, 0) > 0 THEN 
                (mi.total_consumed / mrda.base_value * 100)::NUMERIC(5,2)
            ELSE 0::NUMERIC(5,2)
        END
    FROM (
        SELECT 
            min.mineral_id,
            min.name,
            min.unit,
            COALESCE(SUM(
                (fn.amount_per_100g * um2.weight_g / 100.0)
            ), 0) as total_consumed
        FROM Mineral min
        LEFT JOIN nutrientmapping nm2 ON min.code = nm2.nutrient_code AND nm2.nutrient_type = 'mineral'
        LEFT JOIN FoodNutrient fn ON nm2.nutrient_id = fn.nutrient_id
        LEFT JOIN (
            SELECT 
                mi2.food_id,
                mi2.weight_g
            FROM Meal m2
            JOIN MealItem mi2 ON m2.meal_id = mi2.meal_id
            WHERE m2.user_id = p_user_id 
            AND m2.meal_date = p_date
        ) um2 ON fn.food_id = um2.food_id
        GROUP BY min.mineral_id, min.name, min.unit
    ) mi
    LEFT JOIN MineralRDA mrda ON mi.mineral_id = mrda.mineral_id;
END;
$$ LANGUAGE plpgsql;

-- Source: fix_nutrient_notifications.sql
CREATE TABLE IF NOT EXISTS UserNutrientTracking (
    tracking_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    nutrient_type VARCHAR(20) NOT NULL,
    nutrient_id INT NOT NULL,
    target_amount NUMERIC(10,3),
    current_amount NUMERIC(10,3) DEFAULT 0,
    unit VARCHAR(20),
    last_updated TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, date, nutrient_type, nutrient_id)
);
CREATE TABLE IF NOT EXISTS UserNutrientNotification (
    notification_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    nutrient_type VARCHAR(20) NOT NULL,
    nutrient_id INT NOT NULL,
    nutrient_name VARCHAR(100),
    notification_type VARCHAR(50) NOT NULL,
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    severity VARCHAR(20) DEFAULT 'info',
    is_read BOOLEAN DEFAULT FALSE,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE OR REPLACE FUNCTION calculate_daily_nutrient_intake(
    p_user_id INT,
    p_date DATE
) RETURNS TABLE(
    nutrient_type VARCHAR(20),
    nutrient_id INT,
    nutrient_name VARCHAR(100),
    total_amount NUMERIC(10,3),
    target_amount NUMERIC(10,3),
    unit VARCHAR(20),
    percent_of_target NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'vitamin'::VARCHAR(20) as nutrient_type,
        v.vitamin_id as nutrient_id,
        v.name::VARCHAR(100) as nutrient_name,
        COALESCE(SUM(vn.amount), 0)::NUMERIC(10,3) as total_amount,
        COALESCE(rda.base_value, 0)::NUMERIC(10,3) as target_amount,
        COALESCE(rda.unit, 'mg')::VARCHAR(20) as unit,
        CASE 
            WHEN COALESCE(rda.base_value, 0) > 0 THEN 
                (COALESCE(SUM(vn.amount), 0) / rda.base_value * 100)::NUMERIC(5,2)
            ELSE 0::NUMERIC(5,2)
        END as percent_of_target
    FROM Vitamin v
    LEFT JOIN VitaminNutrient vn ON v.vitamin_id = vn.vitamin_id
    LEFT JOIN FoodNutrient fn ON vn.nutrient_id = fn.nutrient_id
    LEFT JOIN MealItem mi ON fn.food_id = mi.food_id
    LEFT JOIN Meal m ON mi.meal_id = m.meal_id AND m.user_id = p_user_id AND m.meal_date = p_date
    LEFT JOIN VitaminRDA rda ON v.vitamin_id = rda.vitamin_id
    GROUP BY v.vitamin_id, v.name, rda.base_value, rda.unit
    
    UNION ALL
    
    SELECT 
        'mineral'::VARCHAR(20),
        min.mineral_id,
        min.name::VARCHAR(100),
        COALESCE(SUM(mn.amount), 0)::NUMERIC(10,3),
        COALESCE(rda.base_value, 0)::NUMERIC(10,3),
        COALESCE(rda.unit, 'mg')::VARCHAR(20),
        CASE 
            WHEN COALESCE(rda.base_value, 0) > 0 THEN 
                (COALESCE(SUM(mn.amount), 0) / rda.base_value * 100)::NUMERIC(5,2)
            ELSE 0::NUMERIC(5,2)
        END
    FROM Mineral min
    LEFT JOIN MineralNutrient mn ON min.mineral_id = mn.mineral_id
    LEFT JOIN FoodNutrient fn ON mn.nutrient_id = fn.nutrient_id
    LEFT JOIN MealItem mi ON fn.food_id = mi.food_id
    LEFT JOIN Meal m ON mi.meal_id = m.meal_id AND m.user_id = p_user_id AND m.meal_date = p_date
    LEFT JOIN MineralRDA rda ON min.mineral_id = rda.mineral_id
    GROUP BY min.mineral_id, min.name, rda.base_value, rda.unit;
END;
$$ LANGUAGE plpgsql;

-- Source: schema.sql
CREATE TABLE IF NOT EXISTS "User" (
    user_id SERIAL PRIMARY KEY,
    full_name VARCHAR(100),
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    age INT CHECK (age > 0),
    gender VARCHAR(10) CHECK (gender IN ('male', 'female', 'other')),
    height_cm NUMERIC(5,2) CHECK (height_cm > 0),
    weight_kg NUMERIC(5,2) CHECK (weight_kg > 0),
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS UserProfile (
    user_id INT PRIMARY KEY REFERENCES "User"(user_id) ON DELETE CASCADE,
    activity_level VARCHAR(50),
    diet_type VARCHAR(50),
    allergies TEXT,
    health_goals TEXT,
    goal_type VARCHAR(20),                     -- lose_weight / maintain / gain_weight
    goal_weight NUMERIC(5,2),
    activity_factor NUMERIC(3,2),
    bmr NUMERIC(10,2),                         -- Basal Metabolic Rate
    tdee NUMERIC(10,2),                        -- Total Daily Energy Expenditure
    daily_calorie_target NUMERIC(10,2),
    daily_protein_target NUMERIC(10,2),
    daily_fat_target NUMERIC(10,2),
    daily_carb_target NUMERIC(10,2),
    -- daily_water_target stores the suggested water intake in milliliters per day
    daily_water_target NUMERIC(10,2)
);
CREATE TABLE IF NOT EXISTS UserSetting (
    user_id INT PRIMARY KEY REFERENCES "User"(user_id) ON DELETE CASCADE,
    theme VARCHAR(20) DEFAULT 'light',            -- 'light' / 'dark' / other theme names
    language VARCHAR(10) DEFAULT 'vi',            -- e.g. 'vi', 'en'
    font_size VARCHAR(20) DEFAULT 'medium',       -- 'small' / 'medium' / 'large'
    unit_system VARCHAR(10) DEFAULT 'metric',     -- 'metric' / 'imperial'

    -- Seasonal UI settings
    seasonal_ui_enabled BOOLEAN DEFAULT FALSE,   -- bật/tắt chế độ giao diện theo mùa
    seasonal_mode VARCHAR(20) DEFAULT 'auto',    -- 'auto' (theo tháng) / 'manual' / 'off'
    seasonal_custom_bg TEXT,                      -- URL của ảnh background tuỳ chỉnh cho chế độ mùa (nếu người dùng chọn)
    falling_leaves_enabled BOOLEAN DEFAULT TRUE, -- hiệu ứng lá rụng (app có thể đã có sẵn)

    -- Weather-based background / theme
    weather_enabled BOOLEAN DEFAULT FALSE,       -- bật/tắt cập nhật giao diện theo thời tiết
    weather_city VARCHAR(100),                    -- tên thành phố do người dùng nhập (e.g. 'Cà Mau', 'TP HCM')
    weather_last_update TIMESTAMP,                -- thời điểm lần cuối cập nhật weather
    weather_last_data JSONB,                      -- lưu payload thời tiết thô (có thể chứa icon, temp, condition)

    -- Backward-compatible single-image field
    background_image_url TEXT                      -- ảnh background chung (nếu có)
    ,calorie_multiplier NUMERIC(4,2),              -- optional multiplier (e.g., 0.85, 1.15)
    macro_protein_pct NUMERIC(5,2),                -- percent values (e.g., 25.00)
    macro_fat_pct NUMERIC(5,2),
    macro_carb_pct NUMERIC(5,2)
    ,wind_direction DOUBLE PRECISION DEFAULT 0,    -- preferred wind direction in degrees 0..360
    weather_effects_enabled BOOLEAN DEFAULT TRUE  -- whether weather effects (icons/overlays) are enabled
);
CREATE TABLE IF NOT EXISTS UserActivityLog (
    log_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    action TEXT,
    log_time TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS Admin (
    admin_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS Role (
    role_id SERIAL PRIMARY KEY,
    role_name VARCHAR(50) UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS AdminRole (
    admin_id INT REFERENCES Admin(admin_id) ON DELETE CASCADE,
    role_id INT REFERENCES Role(role_id) ON DELETE CASCADE,
    PRIMARY KEY (admin_id, role_id)
);
CREATE TABLE IF NOT EXISTS Food (
    food_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    category VARCHAR(50),
    image_url TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    created_by_admin INT REFERENCES Admin(admin_id) ON DELETE SET NULL
);
CREATE TABLE IF NOT EXISTS Nutrient (
    nutrient_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    nutrient_code VARCHAR(50),
    unit VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    created_by_admin INT REFERENCES Admin(admin_id) ON DELETE SET NULL
);
CREATE TABLE IF NOT EXISTS FoodNutrient (
    food_nutrient_id SERIAL PRIMARY KEY,
    food_id INT REFERENCES Food(food_id) ON DELETE CASCADE,
    nutrient_id INT REFERENCES Nutrient(nutrient_id) ON DELETE CASCADE,
    amount_per_100g NUMERIC(10,2) NOT NULL CHECK (amount_per_100g >= 0)
);
CREATE TABLE IF NOT EXISTS FoodTag (
    tag_id SERIAL PRIMARY KEY,
    tag_name VARCHAR(50) NOT NULL
);
CREATE TABLE IF NOT EXISTS FoodTagMapping (
    food_id INT REFERENCES Food(food_id) ON DELETE CASCADE,
    tag_id INT REFERENCES FoodTag(tag_id) ON DELETE CASCADE,
    PRIMARY KEY (food_id, tag_id)
);
CREATE TABLE IF NOT EXISTS Meal (
    meal_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    meal_type VARCHAR(20) CHECK (meal_type IN ('breakfast','lunch','dinner','snack')),
    meal_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS MealItem (
    meal_item_id SERIAL PRIMARY KEY,
    meal_id INT REFERENCES Meal(meal_id) ON DELETE CASCADE,
    food_id INT REFERENCES Food(food_id) ON DELETE CASCADE,
    weight_g NUMERIC(10,2) NOT NULL CHECK (weight_g > 0)
);
CREATE TABLE IF NOT EXISTS MealNote (
    note_id SERIAL PRIMARY KEY,
    meal_id INT REFERENCES Meal(meal_id) ON DELETE CASCADE,
    note TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS DailySummary (
    summary_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    date DATE NOT NULL,
    total_calories NUMERIC(10,2) DEFAULT 0,
    total_protein NUMERIC(10,2) DEFAULT 0,
    total_fiber NUMERIC(10,2) DEFAULT 0,
    total_carbs NUMERIC(10,2) DEFAULT 0,
    total_fat NUMERIC(10,2) DEFAULT 0
);
CREATE TABLE IF NOT EXISTS Suggestion (
    suggestion_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    date DATE NOT NULL,
    nutrient_id INT REFERENCES Nutrient(nutrient_id),
    deficiency_amount NUMERIC(10,2),
    suggested_food_id INT REFERENCES Food(food_id),
    note TEXT
);
CREATE TABLE IF NOT EXISTS HealthCondition (
    health_condition_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    condition_name VARCHAR(100) NOT NULL,
    severity VARCHAR(50)
);
CREATE TABLE IF NOT EXISTS UserGoal (
    goal_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    goal_type VARCHAR(20) NOT NULL,
    goal_weight NUMERIC(5,2),
    activity_factor NUMERIC(3,2),
    bmr NUMERIC(10,2),
    tdee NUMERIC(10,2),
    daily_calorie_target NUMERIC(10,2),
    daily_protein_target NUMERIC(10,2),
    daily_fat_target NUMERIC(10,2),
    daily_carb_target NUMERIC(10,2),
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS ConditionNutrientEffect (
    condition_effect_id SERIAL PRIMARY KEY,
    condition_name VARCHAR(100) NOT NULL,
    nutrient_id INT REFERENCES Nutrient(nutrient_id) ON DELETE CASCADE,
    effect_type VARCHAR(10) CHECK (effect_type IN ('increase', 'decrease')),
    impact_percent NUMERIC(5,2) DEFAULT 0,
    impact_note TEXT
);
CREATE TABLE IF NOT EXISTS ConditionFoodRecommendation (
    recommendation_id SERIAL PRIMARY KEY,
    condition_name VARCHAR(100) NOT NULL,
    food_id INT REFERENCES Food(food_id) ON DELETE CASCADE,
    recommendation_type VARCHAR(10) CHECK (recommendation_type IN ('recommend', 'avoid')),
    note TEXT
);
CREATE TABLE IF NOT EXISTS ConditionEffectLog (
    effect_log_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    condition_name VARCHAR(100),
    nutrient_id INT REFERENCES Nutrient(nutrient_id),
    effect_type VARCHAR(10),
    impact_percent NUMERIC(5,2),
    applied_at TIMESTAMP DEFAULT NOW()
);
ALTER TABLE MealItem
        ADD COLUMN IF NOT EXISTS calories NUMERIC(10,2) DEFAULT 0,
        ADD COLUMN IF NOT EXISTS protein NUMERIC(10,2) DEFAULT 0,
        ADD COLUMN IF NOT EXISTS fat NUMERIC(10,2) DEFAULT 0,
        ADD COLUMN IF NOT EXISTS carbs NUMERIC(10,2) DEFAULT 0;
CREATE OR REPLACE FUNCTION compute_mealitem_nutrients() RETURNS trigger AS $$
DECLARE
        v_kcal NUMERIC := 0;
        v_protein NUMERIC := 0;
        v_fat NUMERIC := 0;
        v_carb NUMERIC := 0;
BEGIN
        -- Defensive: if no food_id provided, keep zeros
        IF NEW.food_id IS NULL THEN
                NEW.calories := 0;
                NEW.protein := 0;
                NEW.fat := 0;
                NEW.carbs := 0;
                RETURN NEW;
        END IF;

        -- Preferred: match by canonical nutrient_code (if available). Codes follow common standards e.g. ENERC_KCAL, PROCNT, FAT, CHOCDF
        SELECT fn.amount_per_100g
            INTO v_kcal
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id
          AND n.nutrient_code = 'ENERC_KCAL'
        LIMIT 1;

        SELECT fn.amount_per_100g
            INTO v_protein
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id
          AND n.nutrient_code = 'PROCNT'
        LIMIT 1;

        SELECT fn.amount_per_100g
            INTO v_fat
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id
          AND n.nutrient_code = 'FAT'
        LIMIT 1;

        SELECT fn.amount_per_100g
            INTO v_carb
        FROM FoodNutrient fn
        JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id
        WHERE fn.food_id = NEW.food_id
          AND n.nutrient_code = 'CHOCDF'
        LIMIT 1;

        -- Fallback: if code-based lookup returned null, try fuzzy name/unit heuristics for backwards compatibility
        IF v_kcal IS NULL OR v_kcal = 0 THEN
            SELECT fn.amount_per_100g INTO v_kcal FROM FoodNutrient fn JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id WHERE fn.food_id = NEW.food_id AND ( lower(n.name) LIKE '%calor%' OR lower(n.name) LIKE '%energy%' OR lower(n.unit) LIKE '%kcal%') LIMIT 1;
        END IF;
        IF v_protein IS NULL OR v_protein = 0 THEN
            SELECT fn.amount_per_100g INTO v_protein FROM FoodNutrient fn JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id WHERE fn.food_id = NEW.food_id AND lower(n.name) LIKE '%protein%' LIMIT 1;
        END IF;
        IF v_fat IS NULL OR v_fat = 0 THEN
            SELECT fn.amount_per_100g INTO v_fat FROM FoodNutrient fn JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id WHERE fn.food_id = NEW.food_id AND lower(n.name) LIKE '%fat%' LIMIT 1;
        END IF;
        IF v_carb IS NULL OR v_carb = 0 THEN
            SELECT fn.amount_per_100g INTO v_carb FROM FoodNutrient fn JOIN Nutrient n ON n.nutrient_id = fn.nutrient_id WHERE fn.food_id = NEW.food_id AND (lower(n.name) LIKE '%carb%' OR lower(n.name) LIKE '%carbo%') LIMIT 1;
        END IF;

        -- Null-safe
        v_kcal := COALESCE(v_kcal, 0);
        v_protein := COALESCE(v_protein, 0);
        v_fat := COALESCE(v_fat, 0);
        v_carb := COALESCE(v_carb, 0);

        -- compute per item (weight_g is per-item weight in grams)
        NEW.calories := round((v_kcal * NEW.weight_g) / 100.0, 2);
        NEW.protein := round((v_protein * NEW.weight_g) / 100.0, 2);
        NEW.fat := round((v_fat * NEW.weight_g) / 100.0, 2);
        NEW.carbs := round((v_carb * NEW.weight_g) / 100.0, 2);

        RETURN NEW;
END;
$$ LANGUAGE plpgsql;
create triggers
DROP TRIGGER IF EXISTS trg_compute_mealitem_nutrients ON MealItem;
CREATE TRIGGER trg_adjust_daily_summary_mealitem
AFTER INSERT OR UPDATE OR DELETE ON MealItem
FOR EACH ROW EXECUTE FUNCTION adjust_daily_summary_on_mealitem_change();
CREATE TRIGGER trg_compute_userprofile_daily_water
BEFORE INSERT OR UPDATE ON UserProfile
FOR EACH ROW EXECUTE FUNCTION compute_userprofile_daily_water_target();
CREATE TRIGGER trg_user_weight_changed
AFTER UPDATE OF weight_kg ON "User"
FOR EACH ROW
WHEN (OLD.weight_kg IS DISTINCT FROM NEW.weight_kg)
EXECUTE FUNCTION notify_user_weight_change();
CREATE TABLE IF NOT EXISTS Vitamin (
    vitamin_id SERIAL PRIMARY KEY,
    code VARCHAR(50) UNIQUE NOT NULL,        -- short code e.g. VITD, VITC
    name VARCHAR(100) NOT NULL,              -- human-friendly name
    description TEXT,                        -- optional short description
    unit VARCHAR(20) DEFAULT 'mg',           -- unit for RDA (mg, IU, µg, etc.)
    recommended_daily NUMERIC(10,3),         -- recommended daily amount in unit above
    created_at TIMESTAMP DEFAULT NOW(),
    created_by_admin INT REFERENCES Admin(admin_id) ON DELETE SET NULL
);
CREATE OR REPLACE FUNCTION upsert_daily_summary(p_user_id INT, p_date DATE, p_cal NUMERIC, p_prot NUMERIC, p_fat NUMERIC, p_carb NUMERIC) RETURNS VOID AS $$
BEGIN
        INSERT INTO DailySummary(user_id, date, total_calories, total_protein, total_fat, total_carbs)
        VALUES (p_user_id, p_date, COALESCE(p_cal,0), COALESCE(p_prot,0), COALESCE(p_fat,0), COALESCE(p_carb,0))
        ON CONFLICT (user_id, date) DO UPDATE
        SET total_calories = DailySummary.total_calories + EXCLUDED.total_calories,
            total_protein = DailySummary.total_protein + EXCLUDED.total_protein,
            total_fat = DailySummary.total_fat + EXCLUDED.total_fat,
            total_carbs = DailySummary.total_carbs + EXCLUDED.total_carbs;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION adjust_daily_summary_on_mealitem_change() RETURNS trigger AS $$
DECLARE
        v_user INT;
        v_date DATE;
BEGIN
        IF TG_OP = 'INSERT' THEN
                SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = NEW.meal_id;
                PERFORM upsert_daily_summary(v_user, v_date, NEW.calories, NEW.protein, NEW.fat, NEW.carbs);
                RETURN NEW;
        ELSIF TG_OP = 'UPDATE' THEN
                SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = NEW.meal_id;
                -- if meal_date or user changed, handle decrement on old row and increment on new
                IF (OLD.meal_id IS DISTINCT FROM NEW.meal_id) THEN
                        -- decrement old
                        SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = OLD.meal_id;
                        UPDATE DailySummary SET total_calories = GREATEST(total_calories - COALESCE(OLD.calories,0),0), total_protein = GREATEST(total_protein - COALESCE(OLD.protein,0),0), total_fat = GREATEST(total_fat - COALESCE(OLD.fat,0),0), total_carbs = GREATEST(total_carbs - COALESCE(OLD.carbs,0),0) WHERE user_id = v_user AND date = v_date;
                        -- increment new
                        SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = NEW.meal_id;
                        PERFORM upsert_daily_summary(v_user, v_date, NEW.calories, NEW.protein, NEW.fat, NEW.carbs);
                ELSE
                        -- same meal: apply delta
                        UPDATE DailySummary SET
                            total_calories = GREATEST(total_calories + COALESCE(NEW.calories,0) - COALESCE(OLD.calories,0),0),
                            total_protein = GREATEST(total_protein + COALESCE(NEW.protein,0) - COALESCE(OLD.protein,0),0),
                            total_fat = GREATEST(total_fat + COALESCE(NEW.fat,0) - COALESCE(OLD.fat,0),0),
                            total_carbs = GREATEST(total_carbs + COALESCE(NEW.carbs,0) - COALESCE(OLD.carbs,0),0)
                        WHERE user_id = v_user AND date = v_date;
                END IF;
                RETURN NEW;
        ELSIF TG_OP = 'DELETE' THEN
            SELECT meal_date, user_id INTO v_date, v_user FROM Meal WHERE meal_id = OLD.meal_id;
            UPDATE DailySummary SET total_calories = GREATEST(total_calories - COALESCE(OLD.calories,0),0), total_protein = GREATEST(total_protein - COALESCE(OLD.protein,0),0), total_fat = GREATEST(total_fat - COALESCE(OLD.fat,0),0), total_carbs = GREATEST(total_carbs - COALESCE(OLD.carbs,0),0) WHERE user_id = v_user AND date = v_date;
                RETURN OLD;
        END IF;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS UserVitaminRequirement (
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    vitamin_id INT REFERENCES Vitamin(vitamin_id) ON DELETE CASCADE,
    base NUMERIC,
    multiplier NUMERIC,
    recommended NUMERIC,
    unit TEXT,
    updated_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, vitamin_id)
);
CREATE TRIGGER trg_userprofile_vitamin_refresh
AFTER INSERT OR UPDATE OF activity_factor, tdee, goal_type ON UserProfile
FOR EACH ROW EXECUTE FUNCTION trg_refresh_user_vitamins_from_userprofile();
CREATE TRIGGER trg_user_vitamin_refresh
AFTER UPDATE OF weight_kg, gender ON "User"
FOR EACH ROW WHEN (OLD.weight_kg IS DISTINCT FROM NEW.weight_kg OR OLD.gender IS DISTINCT FROM NEW.gender)
EXECUTE FUNCTION trg_refresh_user_vitamins_from_user();
CREATE TABLE IF NOT EXISTS VitaminRDA (
        vitamin_rda_id SERIAL PRIMARY KEY,
        vitamin_id INT REFERENCES Vitamin(vitamin_id) ON DELETE CASCADE,
        sex VARCHAR(10), -- 'male','female',NULL=both
        age_min INT,
        age_max INT,
        rda_value NUMERIC(10,3),
        unit VARCHAR(20),
        notes TEXT
    );
CREATE TABLE IF NOT EXISTS Mineral (
    mineral_id SERIAL PRIMARY KEY,
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    unit VARCHAR(20) DEFAULT 'mg',
    recommended_daily NUMERIC(10,3),
    created_at TIMESTAMP DEFAULT NOW(),
    created_by_admin INT REFERENCES Admin(admin_id) ON DELETE SET NULL
);
CREATE TABLE IF NOT EXISTS MineralRDA (
    mineral_rda_id SERIAL PRIMARY KEY,
    mineral_id INT REFERENCES Mineral(mineral_id) ON DELETE CASCADE,
    sex VARCHAR(10), -- 'male','female',NULL=both
    age_min INT,
    age_max INT,
    rda_value NUMERIC(10,3),
    unit VARCHAR(20),
    notes TEXT
);
CREATE TABLE IF NOT EXISTS UserMineralRequirement (
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    mineral_id INT REFERENCES Mineral(mineral_id) ON DELETE CASCADE,
    base NUMERIC,
    multiplier NUMERIC,
    recommended NUMERIC,
    unit TEXT,
    updated_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, mineral_id)
);
CREATE OR REPLACE FUNCTION compute_userprofile_daily_water_target() RETURNS trigger AS $$
DECLARE
    v_weight NUMERIC;
    v_tdee NUMERIC;
    v_activity NUMERIC;
    v_water_ml NUMERIC;
BEGIN
    -- load weight from User table
    SELECT weight_kg INTO v_weight FROM "User" WHERE user_id = NEW.user_id;

    v_tdee := NEW.tdee;
    v_activity := NEW.activity_factor;

    -- if any required value is missing, do not overwrite manual value
    IF v_weight IS NULL OR v_tdee IS NULL OR v_activity IS NULL THEN
        RETURN NEW;
    END IF;

    -- compute using agreed formula and ensure non-negative
    v_water_ml := ROUND( (v_tdee * 1.0) + (v_weight * 5 * (v_activity - 1.2)), 2 );
    v_water_ml := GREATEST(v_water_ml, 0);

    NEW.daily_water_target := v_water_ml;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trg_userprofile_mineral_refresh
AFTER INSERT OR UPDATE OF activity_factor, tdee, goal_type ON UserProfile
FOR EACH ROW EXECUTE FUNCTION trg_refresh_user_minerals_from_userprofile();
CREATE TRIGGER trg_user_mineral_refresh
AFTER UPDATE OF weight_kg, gender ON "User"
FOR EACH ROW WHEN (OLD.weight_kg IS DISTINCT FROM NEW.weight_kg OR OLD.gender IS DISTINCT FROM NEW.gender)
EXECUTE FUNCTION trg_refresh_user_minerals_from_user();
CREATE OR REPLACE FUNCTION notify_user_weight_change() RETURNS trigger AS $$
BEGIN
    -- if the user has a UserProfile row, do a no-op update to fire the UserProfile triggers
    IF EXISTS (SELECT 1 FROM UserProfile WHERE user_id = NEW.user_id) THEN
        UPDATE UserProfile SET tdee = tdee WHERE user_id = NEW.user_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS Fiber (
    fiber_id SERIAL PRIMARY KEY,
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    unit VARCHAR(20) DEFAULT 'g',
    hex_color VARCHAR(7),
    home_display BOOLEAN DEFAULT FALSE,
    is_user_editable BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS FattyAcid (
    fatty_acid_id SERIAL PRIMARY KEY,
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(150) NOT NULL,
    description TEXT,
    unit VARCHAR(20) DEFAULT 'g',
    hex_color VARCHAR(7),
    home_display BOOLEAN DEFAULT FALSE,
    is_user_editable BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS FiberRequirement (
    fiber_req_id SERIAL PRIMARY KEY,
    fiber_id INT REFERENCES Fiber(fiber_id) ON DELETE CASCADE,
    sex VARCHAR(10),
    age_min INT,
    age_max INT,
    base_value NUMERIC(10,6),
    unit VARCHAR(20) DEFAULT 'g',
    is_per_kg BOOLEAN DEFAULT FALSE,
    is_energy_pct BOOLEAN DEFAULT FALSE,
    energy_pct NUMERIC(6,4),
    notes TEXT
);
CREATE TABLE IF NOT EXISTS FattyAcidRequirement (
    fa_req_id SERIAL PRIMARY KEY,
    fatty_acid_id INT REFERENCES FattyAcid(fatty_acid_id) ON DELETE CASCADE,
    sex VARCHAR(10),
    age_min INT,
    age_max INT,
    base_value NUMERIC(12,6),
    unit VARCHAR(20) DEFAULT 'g',
    is_per_kg BOOLEAN DEFAULT FALSE,
    is_energy_pct BOOLEAN DEFAULT FALSE,
    energy_pct NUMERIC(6,4),
    notes TEXT
);
CREATE TABLE IF NOT EXISTS UserFiberRequirement (
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    fiber_id INT REFERENCES Fiber(fiber_id) ON DELETE CASCADE,
    base NUMERIC,
    multiplier NUMERIC,
    recommended NUMERIC,
    unit TEXT,
    updated_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, fiber_id)
);
CREATE TABLE IF NOT EXISTS UserFattyAcidRequirement (
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    fatty_acid_id INT REFERENCES FattyAcid(fatty_acid_id) ON DELETE CASCADE,
    base NUMERIC,
    multiplier NUMERIC,
    recommended NUMERIC,
    unit TEXT,
    updated_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, fatty_acid_id)
);
CREATE OR REPLACE FUNCTION upsert_vitamin(p_code TEXT, p_name TEXT, p_description TEXT, p_unit TEXT, p_recommended NUMERIC) RETURNS INT AS $$
DECLARE
    v_id INT;
BEGIN
    INSERT INTO Vitamin(code,name,description,unit,recommended_daily,created_by_admin)
    VALUES (p_code, p_name, p_description, p_unit, p_recommended, NULL)
    ON CONFLICT (code) DO UPDATE
    SET name = EXCLUDED.name,
        description = EXCLUDED.description,
        unit = EXCLUDED.unit,
        recommended_daily = EXCLUDED.recommended_daily
    RETURNING vitamin_id INTO v_id;
    RETURN v_id;
END;
$$ LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS UserFiberIntake (
    intake_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    date DATE NOT NULL,
    fiber_id INT REFERENCES Fiber(fiber_id) ON DELETE CASCADE,
    amount NUMERIC(12,4) DEFAULT 0
);
CREATE TABLE IF NOT EXISTS UserFattyAcidIntake (
    intake_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    date DATE NOT NULL,
    fatty_acid_id INT REFERENCES FattyAcid(fatty_acid_id) ON DELETE CASCADE,
    amount NUMERIC(12,4) DEFAULT 0
);
CREATE OR REPLACE FUNCTION upsert_vitamin_by_name(p_name TEXT, p_unit TEXT, p_recommended NUMERIC) RETURNS INT AS $$
DECLARE
    v_code TEXT := 'VIT' || regexp_replace(upper(coalesce(p_name,'')), '[^A-Z0-9]', '', 'g');
BEGIN
    RETURN upsert_vitamin(v_code, p_name, NULL, p_unit, p_recommended);
END;
$$ LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS NutrientMapping (
    mapping_id SERIAL PRIMARY KEY,
    nutrient_id INT REFERENCES Nutrient(nutrient_id) ON DELETE CASCADE,
    fiber_id INT REFERENCES Fiber(fiber_id) ON DELETE CASCADE,
    fatty_acid_id INT REFERENCES FattyAcid(fatty_acid_id) ON DELETE CASCADE,
    factor NUMERIC(10,6) DEFAULT 1.0,
    notes TEXT,
    UNIQUE(nutrient_id)
);
CREATE OR REPLACE FUNCTION compute_user_vitamin_requirement(p_user_id INT, p_vitamin_id INT)
RETURNS TABLE(base NUMERIC, multiplier NUMERIC, recommended NUMERIC, unit TEXT) AS $$
DECLARE
    v_base NUMERIC;
    v_unit TEXT;
    v_gender TEXT;
    v_goal TEXT;
    v_activity NUMERIC;
    v_weight NUMERIC;
    v_tdee NUMERIC;
    v_age INT;
    v_mult NUMERIC := 1.0;
BEGIN
    -- prefer age/sex-specific RDA if available in VitaminRDA, otherwise fall back to Vitamin.recommended_daily
    SELECT r.rda_value, r.unit INTO v_base, v_unit
    FROM VitaminRDA r
    WHERE r.vitamin_id = p_vitamin_id
      AND (r.sex IS NULL OR lower(r.sex) = lower((SELECT COALESCE(u.gender,'') FROM "User" u WHERE u.user_id = p_user_id)))
      AND ( (r.age_min IS NULL AND r.age_max IS NULL) OR (
            (SELECT COALESCE(u.age,0) FROM "User" u WHERE u.user_id = p_user_id) BETWEEN COALESCE(r.age_min, -9999) AND COALESCE(r.age_max, 99999)
          ) )
    LIMIT 1;

    IF v_base IS NULL THEN
        SELECT v2.recommended_daily, v2.unit INTO v_base, v_unit FROM Vitamin v2 WHERE v2.vitamin_id = p_vitamin_id;
    END IF;
    IF v_base IS NULL THEN
        RETURN; -- vitamin not found
    END IF;

    SELECT u.gender, up.goal_type, COALESCE(up.activity_factor,1.2), u.weight_kg, COALESCE(up.tdee,0), u.age
    INTO v_gender, v_goal, v_activity, v_weight, v_tdee, v_age
    FROM "User" u LEFT JOIN UserProfile up ON up.user_id = u.user_id
    WHERE u.user_id = p_user_id;

    IF v_activity IS NULL THEN v_activity := 1.2; END IF;

    -- activity adjustment: small increase for more active users (scaled, capped)
    IF v_activity > 1.2 THEN
        v_mult := v_mult + LEAST( (v_activity - 1.2) * 0.25, 0.20 );
    END IF;

    -- goal adjustment: slight changes for weight goals
    IF v_goal IS NOT NULL THEN
        IF lower(v_goal) = 'lose_weight' THEN
            v_mult := v_mult + 0.05; -- modest increase for dieting demands
        ELSIF lower(v_goal) = 'gain_weight' THEN
            v_mult := v_mult - 0.02; -- small decrease
        END IF;
    END IF;

    -- gender example tweak (optional): small increase for males on average
    IF v_gender IS NOT NULL AND lower(v_gender) = 'male' THEN
        v_mult := v_mult + 0.02;
    END IF;

    -- clamp sensible multiplier bounds
    IF v_mult < 0.5 THEN v_mult := 0.5; END IF;
    IF v_mult > 2.0 THEN v_mult := 2.0; END IF;

    RETURN QUERY SELECT v_base, v_mult, ROUND(v_base * v_mult, 3), v_unit;
END;
$$ LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS AminoAcid (
    amino_acid_id SERIAL PRIMARY KEY,
    code VARCHAR(32) UNIQUE NOT NULL,
    name VARCHAR(128) NOT NULL,
    hex_color VARCHAR(7) NOT NULL,
    home_display BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
CREATE TABLE IF NOT EXISTS AminoRequirement (
    amino_requirement_id SERIAL PRIMARY KEY,
    amino_acid_id INT NOT NULL REFERENCES AminoAcid(amino_acid_id) ON DELETE CASCADE,
    sex VARCHAR(16) DEFAULT 'both',
    age_min INT,
    age_max INT,
    per_kg BOOLEAN NOT NULL DEFAULT FALSE,
    amount NUMERIC NOT NULL,
    unit VARCHAR(16) DEFAULT 'mg',
    notes TEXT
);
CREATE TABLE IF NOT EXISTS UserAminoRequirement (
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    amino_acid_id INT REFERENCES AminoAcid(amino_acid_id) ON DELETE CASCADE,
    base NUMERIC,
    multiplier NUMERIC,
    recommended NUMERIC,
    unit TEXT,
    updated_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, amino_acid_id)
);
CREATE TABLE IF NOT EXISTS UserAminoIntake (
    intake_id BIGSERIAL PRIMARY KEY,
    user_id INT REFERENCES "User"(user_id) ON DELETE CASCADE,
    amino_acid_id INT REFERENCES AminoAcid(amino_acid_id) ON DELETE CASCADE,
    amount NUMERIC NOT NULL,
    unit VARCHAR(16) DEFAULT 'mg',
    source TEXT,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
CREATE TABLE IF NOT EXISTS user_meal_targets (
  id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
  target_date DATE NOT NULL DEFAULT CURRENT_DATE,
  meal_type VARCHAR(16) NOT NULL,
  target_kcal NUMERIC(10,2) DEFAULT 0,
  target_carbs NUMERIC(10,2) DEFAULT 0,
  target_protein NUMERIC(10,2) DEFAULT 0,
  target_fat NUMERIC(10,2) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE OR REPLACE FUNCTION convert_rda_unit(p_value NUMERIC, p_from_unit TEXT, p_to_unit TEXT, p_vitamin_code TEXT) RETURNS NUMERIC AS $$
DECLARE
    f TEXT := upper(coalesce(p_from_unit,''));
    t TEXT := upper(coalesce(p_to_unit,''));
    code TEXT := upper(coalesce(p_vitamin_code,''));
BEGIN
    IF p_value IS NULL OR f = '' OR t = '' OR f = t THEN RETURN p_value; END IF;
    -- mg <-> µg
    IF f = 'MG' AND t IN ('UG','UG/ML','MCG') THEN
        RETURN p_value * 1000;
    ELSIF (f = 'UG' OR f = 'MCG') AND t = 'MG' THEN
        RETURN p_value / 1000;
    END IF;
    -- IU conversions (limited support for common vitamins)
    IF f = 'IU' AND t IN ('UG','MCG') THEN
        -- Vitamin D: 1 IU = 0.025 µg
        IF code = 'VITD' THEN
            RETURN p_value * 0.025;
        END IF;
        -- Vitamin A (retinol): 1 IU = 0.3 µg retinol
        IF code = 'VITA' THEN
            RETURN p_value * 0.3;
        END IF;
        -- Vitamin E (alpha-tocopherol): approximate 1 IU ≈ 0.67 mg -> convert to µg
        IF code = 'VITE' AND t IN ('MG') THEN
            RETURN p_value * 0.67;
        END IF;
    END IF;
    -- fallback: no conversion known
    RETURN p_value;
END;
$$ LANGUAGE plpgsql;
CREATE TABLE IF NOT EXISTS meal_entries (
  id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
  entry_date DATE NOT NULL DEFAULT CURRENT_DATE,
  meal_type VARCHAR(16) NOT NULL,
  food_id INTEGER,
  weight_g NUMERIC(10,2),
  kcal NUMERIC(10,2) DEFAULT 0,
  carbs NUMERIC(10,2) DEFAULT 0,
  protein NUMERIC(10,2) DEFAULT 0,
  fat NUMERIC(10,2) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE IF NOT EXISTS user_meal_summaries (
  id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES "User"(user_id) ON DELETE CASCADE,
  summary_date DATE NOT NULL DEFAULT CURRENT_DATE,
  meal_type VARCHAR(16) NOT NULL,
  consumed_kcal NUMERIC(12,2) DEFAULT 0,
  consumed_carbs NUMERIC(12,2) DEFAULT 0,
  consumed_protein NUMERIC(12,2) DEFAULT 0,
  consumed_fat NUMERIC(12,2) DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE (user_id, summary_date, meal_type)
);
CREATE OR REPLACE FUNCTION refresh_user_vitamin_requirements(p_user_id INT) RETURNS VOID AS $$
DECLARE
    v RECORD;
    v_base NUMERIC;
    v_mult NUMERIC;
    v_rec NUMERIC;
    v_unit TEXT;
BEGIN
    IF p_user_id IS NULL THEN
        RETURN;
    END IF;

    FOR v IN SELECT vitamin_id FROM Vitamin LOOP
        -- compute using existing helper
        SELECT base, multiplier, recommended, unit INTO v_base, v_mult, v_rec, v_unit FROM compute_user_vitamin_requirement(p_user_id, v.vitamin_id);
        -- upsert into cache table
        INSERT INTO UserVitaminRequirement(user_id, vitamin_id, base, multiplier, recommended, unit, updated_at)
        VALUES (p_user_id, v.vitamin_id, v_base, v_mult, v_rec, v_unit, NOW())
        ON CONFLICT (user_id, vitamin_id) DO UPDATE
        SET base = EXCLUDED.base, multiplier = EXCLUDED.multiplier, recommended = EXCLUDED.recommended, unit = EXCLUDED.unit, updated_at = EXCLUDED.updated_at;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_vitamins_from_userprofile() RETURNS trigger AS $$
BEGIN
    -- refresh for the affected user
    PERFORM refresh_user_vitamin_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_vitamins_from_user() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_vitamin_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION seed_core_vitamins() RETURNS INT AS $$
DECLARE
    v_count INT := 0;
BEGIN
    -- List provided: Vitamin A, D, E, K, C, B1, B2, B3, B5, B6, B7, B9, B12
    PERFORM upsert_vitamin('VITA','Vitamin A','Retinol and provitamin A compounds','µg',700);
    PERFORM upsert_vitamin('VITD','Vitamin D','Supports calcium metabolism and bone health','IU',600);
    PERFORM upsert_vitamin('VITE','Vitamin E','Antioxidant (tocopherols)','mg',15);
    PERFORM upsert_vitamin('VITK','Vitamin K','Needed for blood clotting (K1/K2)','µg',120);
    PERFORM upsert_vitamin('VITC','Vitamin C','Ascorbic acid, antioxidant','mg',75);
    PERFORM upsert_vitamin('VITB1','Vitamin B1 (Thiamine)','Supports energy metabolism','mg',1.2);
    PERFORM upsert_vitamin('VITB2','Vitamin B2 (Riboflavin)','Important for energy production','mg',1.3);
    PERFORM upsert_vitamin('VITB3','Vitamin B3 (Niacin)','Supports metabolism and skin health','mg',16);
    PERFORM upsert_vitamin('VITB5','Vitamin B5 (Pantothenic acid)','Component of coenzyme A','mg',5);
    PERFORM upsert_vitamin('VITB6','Vitamin B6 (Pyridoxine)','Supports metabolism and brain health','mg',1.3);
    PERFORM upsert_vitamin('VITB7','Vitamin B7 (Biotin)','Plays a role in macronutrient metabolism','µg',30);
    PERFORM upsert_vitamin('VITB9','Vitamin B9 (Folate)','Key for cell division and DNA synthesis','µg',400);
    PERFORM upsert_vitamin('VITB12','Vitamin B12 (Cobalamin)','Important for nerve function and blood formation','µg',2.4);

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION upsert_mineral(p_code TEXT, p_name TEXT, p_description TEXT, p_unit TEXT, p_recommended NUMERIC) RETURNS INT AS $$
DECLARE
    v_id INT;
BEGIN
    INSERT INTO Mineral(code,name,description,unit,recommended_daily,created_by_admin)
    VALUES (p_code, p_name, p_description, p_unit, p_recommended, NULL)
    ON CONFLICT (code) DO UPDATE
    SET name = EXCLUDED.name,
        description = EXCLUDED.description,
        unit = EXCLUDED.unit,
        recommended_daily = EXCLUDED.recommended_daily
    RETURNING mineral_id INTO v_id;
    RETURN v_id;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION upsert_mineral_by_name(p_name TEXT, p_unit TEXT, p_recommended NUMERIC) RETURNS INT AS $$
DECLARE
    v_code TEXT := 'MIN' || regexp_replace(upper(coalesce(p_name,'')), '[^A-Z0-9]', '', 'g');
BEGIN
    RETURN upsert_mineral(v_code, p_name, NULL, p_unit, p_recommended);
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION compute_user_mineral_requirement(p_user_id INT, p_mineral_id INT)
RETURNS TABLE(base NUMERIC, multiplier NUMERIC, recommended NUMERIC, unit TEXT) AS $$
DECLARE
    v_base NUMERIC;
    v_unit TEXT;
    v_gender TEXT;
    v_goal TEXT;
    v_activity NUMERIC;
    v_weight NUMERIC;
    v_tdee NUMERIC;
    v_age INT;
    v_mult NUMERIC := 1.0;
BEGIN
    SELECT r.rda_value, r.unit INTO v_base, v_unit
    FROM MineralRDA r
    WHERE r.mineral_id = p_mineral_id
      AND (r.sex IS NULL OR lower(r.sex) = lower((SELECT COALESCE(u.gender,'') FROM "User" u WHERE u.user_id = p_user_id)))
      AND ( (r.age_min IS NULL AND r.age_max IS NULL) OR (
            (SELECT COALESCE(u.age,0) FROM "User" u WHERE u.user_id = p_user_id) BETWEEN COALESCE(r.age_min, -9999) AND COALESCE(r.age_max, 99999)
          ) )
    LIMIT 1;

    IF v_base IS NULL THEN
        SELECT m2.recommended_daily, m2.unit INTO v_base, v_unit FROM Mineral m2 WHERE m2.mineral_id = p_mineral_id;
    END IF;
    IF v_base IS NULL THEN
        RETURN;
    END IF;

    SELECT u.gender, up.goal_type, COALESCE(up.activity_factor,1.2), u.weight_kg, COALESCE(up.tdee,0), u.age
    INTO v_gender, v_goal, v_activity, v_weight, v_tdee, v_age
    FROM "User" u LEFT JOIN UserProfile up ON up.user_id = u.user_id
    WHERE u.user_id = p_user_id;

    IF v_activity IS NULL THEN v_activity := 1.2; END IF;

    IF v_activity > 1.2 THEN
        v_mult := v_mult + LEAST( (v_activity - 1.2) * 0.15, 0.15 );
    END IF;

    IF v_goal IS NOT NULL THEN
        IF lower(v_goal) = 'lose_weight' THEN
            v_mult := v_mult + 0.03;
        ELSIF lower(v_goal) = 'gain_weight' THEN
            v_mult := v_mult - 0.01;
        END IF;
    END IF;

    IF v_gender IS NOT NULL AND lower(v_gender) = 'male' THEN
        v_mult := v_mult + 0.02;
    END IF;

    IF v_mult < 0.5 THEN v_mult := 0.5; END IF;
    IF v_mult > 2.0 THEN v_mult := 2.0; END IF;

    RETURN QUERY SELECT v_base, v_mult, ROUND(v_base * v_mult, 3), v_unit;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION refresh_user_mineral_requirements(p_user_id INT) RETURNS VOID AS $$
DECLARE
    v RECORD;
    v_base NUMERIC;
    v_mult NUMERIC;
    v_rec NUMERIC;
    v_unit TEXT;
BEGIN
    IF p_user_id IS NULL THEN RETURN; END IF;
    FOR v IN SELECT mineral_id FROM Mineral LOOP
        SELECT base, multiplier, recommended, unit INTO v_base, v_mult, v_rec, v_unit FROM compute_user_mineral_requirement(p_user_id, v.mineral_id);
        INSERT INTO UserMineralRequirement(user_id, mineral_id, base, multiplier, recommended, unit, updated_at)
        VALUES (p_user_id, v.mineral_id, v_base, v_mult, v_rec, v_unit, NOW())
        ON CONFLICT (user_id, mineral_id) DO UPDATE
        SET base = EXCLUDED.base, multiplier = EXCLUDED.multiplier, recommended = EXCLUDED.recommended, unit = EXCLUDED.unit, updated_at = EXCLUDED.updated_at;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_minerals_from_userprofile() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_mineral_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION trg_refresh_user_minerals_from_user() RETURNS trigger AS $$
BEGIN
    PERFORM refresh_user_mineral_requirements(NEW.user_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION seed_core_minerals() RETURNS INT AS $$
DECLARE v_count INT := 0;
BEGIN
    PERFORM upsert_mineral('MIN_CA','Calcium (Ca)','Calcium for bones and teeth','mg',1000);
    PERFORM upsert_mineral('MIN_P','Phosphorus (P)','Phosphorus for bone and energy metabolism','mg',700);
    PERFORM upsert_mineral('MIN_MG','Magnesium (Mg)','Magnesium for muscle and nerve function','mg',310);
    PERFORM upsert_mineral('MIN_K','Potassium (K)','Potassium electrolyte','mg',4700);
    PERFORM upsert_mineral('MIN_NA','Sodium (Na)','Sodium electrolyte','mg',1500);
    PERFORM upsert_mineral('MIN_FE','Iron (Fe)','Iron for hemoglobin','mg',18);
    PERFORM upsert_mineral('MIN_ZN','Zinc (Zn)','Zinc for immune function','mg',11);
    PERFORM upsert_mineral('MIN_CU','Copper (Cu)','Copper cofactor','mg',0.9);
    PERFORM upsert_mineral('MIN_MN','Manganese (Mn)','Manganese cofactor','mg',2.3);
    PERFORM upsert_mineral('MIN_I','Iodine (I)','Iodine for thyroid','µg',150);
    PERFORM upsert_mineral('MIN_SE','Selenium (Se)','Selenium antioxidant','µg',55);
    PERFORM upsert_mineral('MIN_CR','Chromium (Cr)','Chromium for metabolism','µg',35);
    PERFORM upsert_mineral('MIN_MO','Molybdenum (Mo)','Molybdenum enzyme cofactor','µg',45);
    PERFORM upsert_mineral('MIN_F','Fluoride (F)','Fluoride for dental health','mg',3.0);
    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- Source: seed_sample_foods.sql
CREATE OR REPLACE FUNCTION add_food_nutrients(
    p_food_name VARCHAR,
    p_calories NUMERIC,
    p_protein NUMERIC,
    p_carbs NUMERIC,
    p_fat NUMERIC,
    p_fiber NUMERIC DEFAULT 0
) RETURNS VOID AS $$
DECLARE
    v_food_id INTEGER;
    v_nutrient_id INTEGER;
BEGIN
    -- Get food_id
    SELECT food_id INTO v_food_id FROM Food WHERE name = p_food_name;
    
    IF v_food_id IS NULL THEN
        RAISE NOTICE 'Food % not found', p_food_name;
        RETURN;
    END IF;

    -- Add Energy (Calories)
    IF p_calories > 0 THEN
        SELECT nutrient_id INTO v_nutrient_id FROM Nutrient WHERE nutrient_code = 'ENERC_KCAL';
        -- Delete existing entry if any
        DELETE FROM FoodNutrient WHERE food_id = v_food_id AND nutrient_id = v_nutrient_id;
        -- Insert new entry
        INSERT INTO FoodNutrient (food_id, nutrient_id, amount_per_100g)
        VALUES (v_food_id, v_nutrient_id, p_calories);
    END IF;

    -- Add Protein
    IF p_protein > 0 THEN
        SELECT nutrient_id INTO v_nutrient_id FROM Nutrient WHERE nutrient_code = 'PROCNT';
        DELETE FROM FoodNutrient WHERE food_id = v_food_id AND nutrient_id = v_nutrient_id;
        INSERT INTO FoodNutrient (food_id, nutrient_id, amount_per_100g)
        VALUES (v_food_id, v_nutrient_id, p_protein);
    END IF;

    -- Add Carbohydrates
    IF p_carbs > 0 THEN
        SELECT nutrient_id INTO v_nutrient_id FROM Nutrient WHERE nutrient_code = 'CHOCDF';
        DELETE FROM FoodNutrient WHERE food_id = v_food_id AND nutrient_id = v_nutrient_id;
        INSERT INTO FoodNutrient (food_id, nutrient_id, amount_per_100g)
        VALUES (v_food_id, v_nutrient_id, p_carbs);
    END IF;

    -- Add Fat
    IF p_fat > 0 THEN
        SELECT nutrient_id INTO v_nutrient_id FROM Nutrient WHERE nutrient_code = 'FAT';
        DELETE FROM FoodNutrient WHERE food_id = v_food_id AND nutrient_id = v_nutrient_id;
        INSERT INTO FoodNutrient (food_id, nutrient_id, amount_per_100g)
        VALUES (v_food_id, v_nutrient_id, p_fat);
    END IF;

    -- Add Fiber
    IF p_fiber > 0 THEN
        SELECT nutrient_id INTO v_nutrient_id FROM Nutrient WHERE nutrient_code = 'FIBTG';
        DELETE FROM FoodNutrient WHERE food_id = v_food_id AND nutrient_id = v_nutrient_id;
        INSERT INTO FoodNutrient (food_id, nutrient_id, amount_per_100g)
        VALUES (v_food_id, v_nutrient_id, p_fiber);
    END IF;
END;
$$ LANGUAGE plpgsql;
